"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[346],{1346:(l,n,t)=>{t.r(n),t.d(n,{DocsRxjsComponent:()=>i});var r=t(1917),c=t(2309),e=t(4650);let i=(()=>{class o{constructor(){this.html='<h1 id="state-adaptrxjs">@state-adapt/rxjs</h1>\n<h2 id="peer-dependencies">Peer Dependencies</h2>\n<p><a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/core\'})); void(0)">@state-adapt/core</a></p>\n<p><a href="https://www.npmjs.com/package/rxjs">rxjs</a></p>\n<h2 id="global-configuration">Global Configuration</h2>\n<p><a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/rxjs#configurestateadaptoptions\'})); void(0)"><code>ConfigureStateAdaptOptions</code></a></p>\n<p><a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/rxjs#configurestateadapt\'})); void(0)"><code>configureStateAdapt</code></a></p>\n<h2 id="sources">Sources</h2>\n<p><a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/rxjs#source\'})); void(0)"><code>source</code></a></p>\n<p><a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/rxjs#type\'})); void(0)"><code>type</code></a></p>\n<p><a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/rxjs#getrequestsources\'})); void(0)"><code>getRequestSources</code></a></p>\n<p><a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/rxjs#torequestsource\'})); void(0)"><code>toRequestSource</code></a></p>\n<p><a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/rxjs#splitrequestsources\'})); void(0)"><code>splitRequestSources</code></a></p>\n<h2 id="stores">Stores</h2>\n<p><a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/rxjs#stateadaptadapt\'})); void(0)"><code>StateAdapt.adapt</code></a></p>\n<p><a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/rxjs#stateadaptwatch\'})); void(0)"><code>StateAdapt.watch</code></a></p>\n<p><a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/rxjs#joinstores\'})); void(0)"><code>joinStores</code></a></p>\n<h2 id="sources-advanced">Sources (Advanced)</h2>\n<p><a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/rxjs#splitsources\'})); void(0)"><code>splitSources</code></a></p>\n<p><a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/rxjs#catcherrorsource\'})); void(0)"><code>catchErrorSource</code></a></p>\n<p><a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/rxjs#tosource\'})); void(0)"><code>toSource</code></a></p>\n<h2 id="migration-guide">Migration Guide</h2>\n<p><a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/rxjs#210\'})); void(0)">2.1.0</a></p>\n<p><a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/rxjs#200\'})); void(0)">2.0.0</a></p>\n\x3c!--  --\x3e\n\x3c!-- ## Global Store --\x3e\n\n\n<h2 id="configurestateadaptoptions"><code>ConfigureStateAdaptOptions</code></h2>\n<p>  <code>ConfigureStateAdaptOptions</code> has 4 possible properties:</p>\n<ul class="bx--list--unordered"><li class="bx--list__item"><code>showSelectors?: boolean</code> (default: <code>true</code>) - determines whether to show StateAdapt selectors in Redux DevTools</li><li class="bx--list__item"><code>store</code>: <code>Store</code> - Redux-like store</li><li class="bx--list__item"><code>devtools: any</code> - options for Redux DevTools</li><li class="bx--list__item"><code>preloadedState?: any</code> -  self-explanatory</li></ul><p>  If <code>store</code> is provided, <code>devtools</code> and <code>preloadedState</code> are ignored.</p>\n<h2 id="configurestateadapt"><code>configureStateAdapt</code></h2>\n<blockquote>\n<p>Copilot tip: Copy examples into your file or click to definition to open file with context for better Copilot suggestions.</p>\n</blockquote>\n<p>  <code>configureStateAdapt</code> takes in a <a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/rxjs#configurestateadaptoptions\'})); void(0)"><code>ConfigureStateAdaptOptions</code></a> object and returns a new instance of <a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/rxjs#stateadapt\'})); void(0)"><code>StateAdapt</code></a>.</p>\n<h3 id="example-standalone-with-default-options">Example: Standalone with default options</h3>\n<pre><code class="language-ts">import { actionSanitizer, stateSanitizer } from &#39;@state-adapt/core&#39;;\nimport { configureStateAdapt } from &#39;@state-adapt/rxjs&#39;;\n\nexport const stateAdapt = configureStateAdapt();\n\nexport const { adapt, watch } = stateAdapt;\n</code></pre>\n<h3 id="example-standalone">Example: Standalone</h3>\n<pre><code class="language-ts">import { actionSanitizer, stateSanitizer } from &#39;@state-adapt/core&#39;;\nimport { configureStateAdapt } from &#39;@state-adapt/rxjs&#39;;\n\nexport const stateAdapt = configureStateAdapt({\n  devtools: (window as any)?.__REDUX_DEVTOOLS_EXTENSION__?.({\n    actionSanitizer,\n    stateSanitizer,\n  }),\n  showSelectors: false,\n});\n\nexport const { adapt, watch } = stateAdapt;\n</code></pre>\n<h3 id="example-with-another-store">Example: With another store</h3>\n<pre><code class="language-ts">import { configureStore } from &#39;@reduxjs/toolkit&#39;; // or any other Redux-like store\nimport { configureStateAdapt } from &#39;@state-adapt/rxjs&#39;;\nimport { reducer } from &#39;./reducer&#39;;\n\nconst store = configureStore({ reducer });\n\nexport const stateAdapt = configureStateAdapt({ store });\n\nexport const { adapt, watch } = stateAdapt;\n</code></pre>\n\x3c!-- ## Sources --\x3e\n\n\n<h2 id="source"><code>source</code></h2>\n<p>  <code>source</code> returns an object that extends an RxJS <a href="https://rxjs.dev/guide/subject">Subject</a> with an extra <code>type: string</code> property, and is also callable directly.\n  When using a <code>source</code>, you can provide a <code>type</code> argument, which will appear as the action type in Redux DevTools:</p>\n<p>  <img src="https://state-adapt.github.io/assets/devtools-add$.png" alt="Action Type in Redux Devtools" /></p>\n<p>  In the future we want to add a build step to add this annotation automatically. That is why source types are optional.</p>\n<h4 id="example-creating-a-source-without-a-type">Example: Creating a source without a type</h4>\n<pre><code class="language-typescript">import { source } from &#39;@state-adapt/rxjs&#39;;\n\nconst add$ = source&lt;number&gt;();\n\nadd$.subscribe(console.log);\n\nadd$.next(1);\n// 1\n\nadd$(2)\n// 2\n</code></pre>\n<h4 id="example-creating-a-source-with-a-type">Example: Creating a source with a type</h4>\n<pre><code class="language-typescript">const add$ = source&lt;number&gt;(&#39;add$&#39;);\n</code></pre>\n<h4 id="example-creating-a-source-with-onevent-naming-convention">Example: Creating a source with onEvent naming convention</h4>\n<pre><code class="language-typescript">import { source } from &#39;@state-adapt/rxjs&#39;;\n\nconst onAdd = source&lt;number&gt;();\n\nonAdd.subscribe(console.log);\n\nonAdd(1)\n// 1\n</code></pre>\n<h2 id="type"><code>type</code></h2>\n<p>  <code>type</code> is a custom RxJS <a href="https://rxjs.dev/guide/operators">operator</a> that mutates an RxJS <a href="https://rxjs.dev/guide/observable">Observable</a>\n  by setting a <code>type</code> property. It takes one argument, which will appear as the action type in Redux DevTools:</p>\n<p>  <img src="https://state-adapt.github.io/assets/devtools-timer$.png" alt="Action Type in Redux Devtools" /></p>\n<h4 id="example-converting-an-observable-into-a-source">Example: Converting an observable into a source</h4>\n<pre><code class="language-typescript">import { timer } from &#39;rxjs&#39;;\nimport { type } from &#39;@state-adapt/rxjs&#39;;\n\nconst timer$ = timer(1000).pipe(type(&#39;timer$&#39;));\n\ntimer$.subscribe(console.log);\n// 0\n</code></pre>\n<h2 id="getrequestsources"><code>getRequestSources</code></h2>\n<p>  <code>getRequestSources</code> takes in a <code>TypePrefix</code> and an <a href="https://rxjs.dev/guide/observable">Observable</a>\n  of values of type <code>Payload</code> (inferred) and returns an object with <code>success$</code> and <code>error$</code> propeties.</p>\n<p>  The <code>success$</code> property is an observable of values of type</p>\n<pre><code class="language-ts">{ type: `${TypePrefix}.success$`; payload: Payload }\n</code></pre>\n<p>  The <code>error$</code> property is an observable of values of type</p>\n<pre><code class="language-ts">{ type: `${TypePrefix}.error$`; payload: any }\n</code></pre>\n<p>  <code>getRequestSources</code> combines the functionality of <a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/rxjs#torequestsource\'})); void(0)"><code>toRequestSource</code></a> and <a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/rxjs#splitrequestsources\'})); void(0)"><code>splitRequestSources</code></a>.</p>\n<p>  Important: RxJS streams complete immediately after they error. For simple HTTP requests, this is fine.\n  But if you need to keep a stream alive, look into using <a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/rxjs#torequestsource\'})); void(0)"><code>toRequestSource</code></a> and <a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/rxjs#splitrequestsources\'})); void(0)"><code>splitRequestSources</code></a>\n  directly.</p>\n<h4 id="example-split-an-http-source-into-success-and-error-sources">Example: Split an HTTP source into success$ and error$ sources</h4>\n<pre><code class="language-typescript">import { ajax } from &#39;rxjs/ajax&#39;;\nimport { getRequestSources } from &#39;@state-adapt/rxjs&#39;;\n\nconst http$ = ajax(&#39;https://jsonplaceholder.typicode.com/todos/1&#39;);\n\nconst todoRequest = getRequestSources(&#39;todo&#39;, http$);\n\ntodoRequest.success$.subscribe(console.log);\n// { type: &#39;todo.success$&#39;, payload: { ... } }\n\ntodoRequest.error$.subscribe(console.log);\n// { type: &#39;todo.error$&#39;, payload: { ... } }\n</code></pre>\n<h4 id="example-convert-any-observable-into-success-and-error-sources">Example: Convert any observable into success$ and error$ sources</h4>\n<pre><code class="language-typescript">import { interval, map } from &#39;rxjs&#39;;\nimport { getRequestSources } from &#39;@state-adapt/rxjs&#39;;\n\nconst interval$ = interval(1000).pipe(\n  map(n =&gt; n !== 2 ? n : (n as any).fakeNumberMethod()),\n);\n\nconst { success$, error$ } = getRequestSources(&#39;interval&#39;, interval$);\n\nsuccess$.subscribe(console.log);\n// { type: &#39;interval.success$&#39;, payload: 0 }\n// { type: &#39;interval.success$&#39;, payload: 1 }\n// Will not log anymore, after error\n\nerror$.subscribe(console.log);\n// { type: &#39;interval.error$&#39;, payload: &#39;Error: n.fakeNumberMethod is not a function&#39; }\n</code></pre>\n<h2 id="torequestsource"><code>toRequestSource</code></h2>\n<p>  <code>toRequestSource</code> takes in a <code>TypePrefix</code> and converts an RxJS <a href="https://rxjs.dev/guide/observable">Observable</a>\n  of values of type <code>Payload</code> (inferred) into an <a href="https://rxjs.dev/guide/observable">Observable</a> of values of type</p>\n<pre><code class="language-ts">| { type: `${TypePrefix}.success$`; payload: Payload }\n| { type: `${TypePrefix}.error$`; payload: any }\n</code></pre>\n<h4 id="example-convert-an-http-post-observable-into-an-observable-with-success-and-error-values">Example: Convert an HTTP POST observable into an observable with <code>success$</code> and <code>error$</code> values</h4>\n<pre><code class="language-typescript">import { exhaustMap } from &#39;rxjs&#39;;\nimport { ajax } from &#39;rxjs/ajax&#39;;\nimport { toRequestSource } from &#39;@state-adapt/rxjs&#39;;\n\nconst deleteTodo$ = source&lt;number&gt;();\n\nconst deleteTodoRequest$ = deleteTodo$.pipe(\n  exhaustMap((id) =&gt;\n    ajax({\n      url: `https://jsonplaceholder.typicode.com/todos/${id}`,\n      method: &#39;DELETE&#39;,\n    }).pipe(toRequestSource(&#39;todo.delete&#39;))\n  )\n);\n\ndeleteTodoRequest$.subscribe(console.log);\n\ndeleteTodo$.next(1);\n// { type: &#39;todo.delete.success$&#39;, payload: AjaxResponse{\u2026} }\n\ndeleteTodo$.next(Infinity);\n// { type: &#39;todo.delete.error$&#39;, payload: &#39;AjaxErrorImpl{\u2026} }\n\ndeleteTodo$.next(2);\n// { type: &#39;todo.delete.success$&#39;, payload: AjaxResponse{\u2026} }\n</code></pre>\n<p>  The main stream is not killed because <code>toRequestSource</code> operates on the request observable\n  instead of the outer observable.</p>\n<h4 id="example-converting-any-observable-into-a-request-source">Example: Converting any observable into a request source</h4>\n<pre><code class="language-typescript">import { interval } from &#39;rxjs&#39;;\nimport { toRequestSource } from &#39;@state-adapt/rxjs&#39;;\n\nconst interval$ = interval(1000).pipe(\n  map(n =&gt; n &lt; 2 ? n : n.fakeNumberMethod()),\n  toRequestSource(&#39;interval&#39;),\n);\n\ninterval$.subscribe(console.log);\n// { type: &#39;interval.success$&#39;, payload: 0 }\n// { type: &#39;interval.success$&#39;, payload: 1 }\n// { type: &#39;interval.error$&#39;, payload: &#39;Error: n.fakeNumberMethod is not a function&#39; }\n// End\n</code></pre>\n<p>  The main stream is killed because <code>toRequestSource</code> operates directly on it\n  instead of on an inner observable.</p>\n<h2 id="splitrequestsources"><code>splitRequestSources</code></h2>\n<p>  <code>splitRequestSources</code> is a function that takes in a <code>TypePrefix</code> and an <a href="https://rxjs.dev/guide/observable">Observable</a> with values of type</p>\n<pre><code class="language-ts">| { type: `${TypePrefix}.success$`; payload: Payload }\n| { type: `${TypePrefix}.error$`; payload: any }\n</code></pre>\n<p>  and returns an object with <code>success$</code> and <code>error$</code> propeties.</p>\n<p>  The <code>success$</code> property is an observable of values of type</p>\n<pre><code class="language-ts">{ type: `${TypePrefix}.success$`; payload: Payload }\n</code></pre>\n<p>  The <code>error$</code> property is an observable of values of type</p>\n<pre><code class="language-ts">{ type: `${TypePrefix}.error$`; payload: any }\n</code></pre>\n<h4 id="example-convert-an-http-post-observable-into-success-and-error-sources">Example: Convert an HTTP POST observable into success$ and error$ sources</h4>\n<pre><code class="language-typescript">import { exhaustMap } from &#39;rxjs&#39;;\nimport { ajax } from &#39;rxjs/ajax&#39;;\nimport { splitRequestSources,  toRequestSource } from &#39;@state-adapt/rxjs&#39;;\n\nconst deleteTodo$ = source&lt;number&gt;();\n\nconst deleteTodoRequest$ = deleteTodo$.pipe(\n  exhaustMap((id) =&gt;\n    ajax({\n      url: `https://jsonplaceholder.typicode.com/todos/${id}`,\n      method: &#39;DELETE&#39;,\n    }).pipe(toRequestSource(&#39;todo.delete&#39;))\n  )\n);\nconst deleteTodoRequest = splitRequestSources(&#39;todo.delete&#39;, deleteTodoRequest$);\n\ntodoRequest.success$.subscribe(console.log);\ntodoRequest.error$.subscribe(console.log);\n\ndeleteTodo$.next(1);\n// { type: &#39;todo.delete.success$&#39;, payload: AjaxResponse{\u2026} }\n\ndeleteTodo$.next(Infinity);\n// { type: &#39;todo.delete.error$&#39;, payload: &#39;AjaxErrorImpl{\u2026} }\n\ndeleteTodo$.next(2);\n// { type: &#39;todo.delete.success$&#39;, payload: AjaxResponse{\u2026} }\n</code></pre>\n<p>  The main stream is not killed because <code>toRequestSource</code> operates on the request observable\n  instead of the outer observable.</p>\n<h4 id="example-splitting-an-observable-of-request-actions-into-success-and-error-sources">Example: Splitting an observable of request actions into success$ and error$ sources</h4>\n<pre><code class="language-typescript">import { interval } from &#39;rxjs&#39;;\nimport { splitRequestSources, toRequestSource } from &#39;@state-adapt/rxjs&#39;;\n\nconst interval$ = interval(1000).pipe(\n  map(n =&gt; n &lt; 2 ? n : n.fakeNumberMethod()),\n  toRequestSource(&#39;interval&#39;),\n);\n\nconst { success$, error$ } = splitRequestSources(&#39;interval&#39;, interval$);\n\nsuccess$.subscribe(console.log);\n// { type: &#39;interval.success$&#39;, payload: 0 }\n// { type: &#39;interval.success$&#39;, payload: 1 }\n// End\n\nerror$.subscribe(console.log);\n// { type: &#39;interval.error$&#39;, payload: &#39;Error: n.fakeNumberMethod is not a function&#39; }\n</code></pre>\n<p>  The main stream is killed because <code>toRequestSource</code> operates directly on it\n  instead of on an inner observable.</p>\n\x3c!-- ## Stores 1.2.0  --\x3e\n\n\n<h2 id="stateadaptadapt"><code>StateAdapt.adapt</code></h2>\n<blockquote>\n<p>Copilot tip: Copy examples into your file or click to definition to open file with context for better Copilot suggestions.</p>\n</blockquote>\n<p>  <code>adapt</code> creates a store that will manage state while it has subscribers.</p>\n<h3 id="example-initialstate-only">Example: initialState only</h3>\n<p>  <code>adapt(initialState)</code></p>\n<p>  The simplest way to use <code>adapt</code> is to only pass it an initial state. <code>adapt</code> returns a store object that is ready to start managing state once it has subscribers.\n  The store object comes with <code>set</code> and <code>reset</code> methods for updating state, and a <code>state$</code> observable of the store&#39;s state.</p>\n<pre><code class="language-typescript">const name = adapt(&#39;John&#39;);\n\nname.state$.subscribe(console.log); // logs &#39;John&#39;\n\nname.set(&#39;Johnsh&#39;); // logs &#39;Johnsh&#39;\nname.reset(); // logs &#39;John&#39;\n</code></pre>\n<p>  Usually you won&#39;t manually subscribe to state like this, but you can if you want the store to immediately start managing state\n  and never clean it up.</p>\n<h3 id="example-using-an-adapter">Example: Using an adapter</h3>\n<p>  <code>adapt(initialState, adapter)</code></p>\n<p>  You can also pass in a state <a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/core#adapter\'})); void(0)"><code>Adapter</code></a> object to customize the state change functions and selectors.</p>\n<pre><code class="language-typescript">const name = adapt(&#39;John&#39;, {\n  concat: (state, payload: string) =&gt; state + payload,\n  selectors: {\n    length: state =&gt; state.length,\n  },\n});\n\nname.state$.subscribe(console.log); // Logs &#39;John&#39;\nname.length$.subscribe(console.log); // Logs 4\n\nname.concat(&#39;sh&#39;); // logs &#39;Johnsh&#39; and 6\nname.reset(); // logs &#39;John&#39; and 4\n</code></pre>\n<h3 id="example-using-adaptoptions">Example: Using <a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/rxjs#adaptoptions\'})); void(0)"><code>AdaptOptions</code></a></h3>\n<p>  <code>adapt(initialState, { adapter, sources, path })</code></p>\n<p>  You can also define an adapter, sources, and/or a state path as part of an <a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/rxjs#adaptoptions\'})); void(0)"><code>AdaptOptions</code></a> object.</p>\n<p>  Sources allow the store to declaratively react to external events rather than being commanded\n  by imperative code in callback functions.</p>\n<pre><code class="language-typescript">const tick$ = interval(1000);\n\nconst clock = adapt(0, {\n  adapter: {\n    increment: state =&gt; state + 1,\n  },\n  sources: tick$, // or [tick$], or { set: tick$ }, or { set: [tick$] }\n  path: &#39;clock&#39;,\n});\n\nclock.state$.subscribe(console.log); // Logs 0, 1, 2, 3, etc.\n</code></pre>\n<p>  When a store is subscribed to, it passes the subscriptions up the its sources.\n  For example, if a store has an HTTP source, it will be triggered when the store\n  receives its first subscriber, and it will be canceled when the store loses its\n  last subscriber.</p>\n<p>  There are 4 possible ways sources can be defined:</p>\n<p>  1. A source can be a single source or <a href="https://rxjs.dev/guide/observable">Observable</a>&lt;<code>State</code>&gt;. When the source emits, it triggers the store&#39;s <code>set</code> method\n  with the payload.</p>\n<h4 id="example-single-source-or-observable">Example: Single source or observable</h4>\n<pre><code class="language-typescript">const nameChange$ = source&lt;string&gt;();\n\nconst name = adapt(&#39;John&#39;, {\n  sources: nameChange$,\n  path: &#39;name&#39;,\n});\n\nname.state$.subscribe(console.log); // Logs &#39;John&#39;\n\nnameChange$.next(&#39;Johnsh&#39;); // logs &#39;Johnsh&#39;\n</code></pre>\n<p>  2. A source can be an array of sources or <a href="https://rxjs.dev/guide/observable">Observable</a>&lt;<code>State</code>&gt;. When any of the sources emit, it triggers the store&#39;s <code>set</code>\n   method with the payload.</p>\n<h4 id="example-array-of-sources-or-observables">Example: Array of sources or observables</h4>\n<pre><code class="language-typescript">const nameChange$ = source&lt;string&gt;();\nconst nameChange2$ = source&lt;string&gt;();\n\nconst name = adapt(&#39;John&#39;, {\n  sources: [nameChange$, nameChange2$],\n  path: &#39;name&#39;,\n});\n\nname.state$.subscribe(console.log); // Logs &#39;John&#39;\n\nnameChange$.next(&#39;Johnsh&#39;); // logs &#39;Johnsh&#39;\nnameChange2$.next(&#39;Johnsh2&#39;); // logs &#39;Johnsh2&#39;\n</code></pre>\n<p>  3. A source can be an object with keys that match the names of the <a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/core#adapter\'})); void(0)"><code>Adapter</code></a> state change functions, with a corresponding source or array of\n  sources that trigger the store&#39;s reaction with the payload.</p>\n<h4 id="example-object-of-sources-or-observables">Example: Object of sources or observables</h4>\n<pre><code class="language-typescript">const nameChange$ = source&lt;string&gt;();\nconst nameReset$ = source&lt;void&gt;();\n\nconst name = adapt(&#39;John&#39;, {\n  sources: {\n    set: nameChange$,\n    reset: nameReset$,\n  },\n  path: &#39;name&#39;,\n});\n\nname.state$.subscribe(console.log); // Logs &#39;John&#39;\n\nnameChange$.next(&#39;Johnsh&#39;); // logs &#39;Johnsh&#39;\nnameReset$.next(); // logs &#39;John&#39;\n</code></pre>\n<p>  4. A source can be a function that takes in a detached store (doesn&#39;t chain off of sources) and returns any of the above\n  types of sources or observables.</p>\n<h4 id="example-function-that-returns-an-observable">Example: Function that returns an observable</h4>\n<pre><code class="language-typescript">const name = adapt(&#39;John&#39;, {\n  sources: store =&gt; store.state$.pipe(\n    delay(1000),\n    map(name =&gt; `${name}sh`),\n  ),\n  path: &#39;name&#39;,\n});\n\nname.state$.subscribe(console.log); // Logs &#39;John&#39;\n// logs &#39;Johnsh&#39; after 1 second, then &#39;Johnshsh&#39; after 2 seconds, etc.\n</code></pre>\n<p>  Defining a path alongside sources is recommended to enable debugging with Redux DevTools. It&#39;s easy to trace\n  singular state changes caused by user events, but it&#39;s much harder to trace state changes caused by RxJS streams.</p>\n<p>  The path string specifies the location in the global store you will find the state for the store being created\n  (while the store has subscribers). StateAdapt splits this string at periods <code>&#39;.&#39;</code> to create an object path within\n  the global store. Here are some example paths and the resulting global state objects:</p>\n<h4 id="example-paths-and-global-state">Example: Paths and global state</h4>\n<pre><code class="language-typescript">const store = adapt(0, { path: &#39;number&#39; });\nstore.state$.subscribe();\n// global state: { number: 0 }\n</code></pre>\n<pre><code class="language-typescript">const store = adapt(0, { path: &#39;featureA.number&#39; });\nstore.state$.subscribe();\n// global state: { featureA: { number: 0 } }\n</code></pre>\n<pre><code class="language-typescript">const store = adapt(0, { path: &#39;featureA.featureB.number&#39; });\nstore.state$.subscribe();\n// global state: { featureA: { featureB: { number: 0 } } }\n</code></pre>\n<p>  Each store completely owns its own state. If more than one store tries to use the same path, StateAdapt will throw this error:</p>\n<p>  <code>Path &#39;${path}&#39; collides with &#39;${existingPath}&#39;, which has already been initialized as a state path.</code></p>\n<p>  This applies both to paths that are identical as well as paths that are subtrings of each other. For example, if <code>&#39;featureA&#39;</code>\n  is already being used by a store and then another store tried to initialize at <code>&#39;featureA.number&#39;</code>, that error would be thrown.</p>\n<p>  To help avoid this error, StateAdapt provides a <a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/core#getid\'})); void(0)"><code>getId</code></a> function that can be used to generate unique paths:</p>\n<h4 id="example-getid-for-unique-paths">Example: getId for unique paths</h4>\n<pre><code class="language-typescript">import { getId } from &#39;@state-adapt/core&#39;;\n\nconst store1 = adapt(0, { path: &#39;number&#39; + getId() });\nstore1.state$.subscribe();\nconst store2 = adapt(0, { path: &#39;number&#39; + getId() });\nstore2.state$.subscribe();\n// global state includes both: { number0: 0, number1: 0 }\n</code></pre>\n<h3 id="no-path">No path</h3>\n<p>  If no path is provided, then the store&#39;s path defaults to the result of calling <a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/core#getid\'})); void(0)"><code>getId</code></a>.</p>\n<h3 id="remember">Remember!</h3>\n<p>  The store needs to have subscribers in order to start managing state,\n  and it only subscribes to sources when it has subscribers itself.</p>\n<h2 id="stateadaptwatch"><code>StateAdapt.watch</code></h2>\n<blockquote>\n<p>Copilot tip: Copy examples into your file or click to definition to open file with context for better Copilot suggestions.</p>\n</blockquote>\n<p>  <code>watch</code> returns a detached store (doesn&#39;t chain off of sources). This allows you to watch state without affecting anything.\n  It takes 2 arguments: The path of the state you are interested in, and the adapter you want to use.</p>\n<pre><code class="language-tsx">watch(path, adapter)\n</code></pre>\n<p>  path \u2014 Object path in Redux Devtools</p>\n<p>  adapter \u2014 Object with state change functions and selectors</p>\n<h3 id="usage">Usage</h3>\n<p>  <code>watch</code> enables accessing state without subscribing to sources. For example, if your adapter manages the loading state\n  for an HTTP request and you need to know if the request is loading before the user is interested in the data,\n  <code>watch</code> can give you access to it without triggering the request.</p>\n<h4 id="example-accessing-loading-state">Example: Accessing loading state</h4>\n<pre><code class="language-tsx">watch(&#39;data&#39;, httpAdapter).loading$.subscribe(console.log);\n</code></pre>\n<h2 id="joinstores"><code>joinStores</code></h2>\n<p>  <code>joinStores</code> is a function that takes in a <code>StoreEntries extends { [index: string]: StoreLike }</code> object and returns a <code>StoreBuilder</code> function.\n  The <code>StoreBuilder</code> function can be called again and again with more selector definitions, and finally with no arguments to create a store.</p>\n<p>  <code>joinStores</code> syntax is identical to that of <a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/core#joinadapters\'})); void(0)"><code>joinAdapters</code></a> so that you can easily switch between the two.\n  The difference is that <code>joinStores</code> can only define selectors, while <code>joinAdapters</code> can define both selectors and reactions.</p>\n<h4 id="example-combining-states-from-two-stores">Example: Combining states from two stores</h4>\n<pre><code class="language-typescript">import { joinStores } from &#39;@state-adapt/rxjs&#39;;\nimport { adapt } from &#39;../configure-state-adapt.ts&#39;;\n\nconst store1 = adapt(1);\nconst store2 = adapt(2);\n\nconst joinedStore = joinStores({ store1, store2 })();\n\njoinedStore.state$.subscribe(console.log);\n// { store1: 1, store2: 2 }\n</code></pre>\n<h4 id="example-combining-selectors-from-two-stores">Example: Combining selectors from two stores</h4>\n<pre><code class="language-typescript">import { createAdapter } from &#39;@state-adapt/core&#39;;\nimport { joinStores } from &#39;@state-adapt/rxjs&#39;;\nimport { adapt } from &#39;../configure-state-adapt.ts&#39;;\n\nconst adapter = createAdapter&lt;number&gt;()({\n  selectors: {\n    double: s =&gt; s * 2,\n  }\n});\n\nconst store1 = adapt(1, adapter);\nconst store2 = adapt(2, adapter);\n\nconst joinedStore = joinStores({ store1, store2 })({\n  sum: s =&gt; s.store1Double + s.store2Double,\n})();\n\njoinedStore.sum$.subscribe(console.log);\n// 6\n</code></pre>\n\x3c!-- ## Sources (Advanced) --\x3e\n\n\n<h2 id="splitsources"><code>splitSources</code></h2>\n<p>  <code>splitSources</code> is a function that takes in an <a href="https://rxjs.dev/guide/observable">Observable</a> that emits multiple types of <a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/core#action\'})); void(0)"><code>Action</code></a> objects and splits it into a source for each <a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/core#action\'})); void(0)"><code>Action</code></a> type.\n  It takes two arguments:</p>\n<ul class="bx--list--unordered"><li class="bx--list__item"><code>source$</code>: <a href="https://rxjs.dev/guide/observable">Observable</a>&lt;<code>CommonAction</code>&gt;</li><li class="bx--list__item"><code>aliases?</code>: <code>Aliases</code> extends { [index: string]: <code>CommonType</code> } \u2014 An optional object with keys that will become the new source names,\n  and values that will filter against the <code>type</code> property of the actions from the <code>source$</code> observable.</li></ul><p>  It returns a proxy object that defines keys from the source types and the <code>aliases</code> argument (if provided),\n  and values of type <a href="https://rxjs.dev/guide/observable">Observable</a>&lt;<a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/core#action\'})); void(0)"><code>Action</code></a>&lt;<code>Payload</code>, <code>Type</code>&gt;&gt;\n  where <code>Payload</code> and <code>Type</code> are inferred from the filtered <code>CommonAction</code> type.</p>\n<p>  If the source type is specific (as in <code>&#39;even$&#39; | &#39;odd$&#39;</code>), the returned object will have <code>&#39;even$&#39;</code> and <code>&#39;odd$&#39;</code> properties.\n  If the source type is just a string, any string can be accessed, and <a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/rxjs#splitsources\'})); void(0)"><code>splitSources</code></a> will filter against that string.\n  The proxy defines this filtered source once the property is accessed.</p>\n<h4 id="example-splitting-a-source-into-multiple-sources">Example: Splitting a source into multiple sources</h4>\n<pre><code class="language-typescript">import { getAction } from &#39;@state-adapt/core&#39;;\nimport { splitSources } from &#39;@state-adapt/rxjs&#39;;\nimport { interval, map } from &#39;rxjs&#39;;\n\nconst evenAndOdd$ = interval(1000).pipe(\n  map(n =&gt; ({\n    // type has to be &#39;even$&#39; | &#39;odd$&#39;, not just a string\n    type: n % 2 === 0 ? (&#39;even$&#39; as const) : (&#39;odd$&#39; as const),\n    payload: n,\n  })),\n);\n\nevenAndOdd$.subscribe(console.log);\n// { type: &#39;even$&#39;, payload: 0 }\n// { type: &#39;odd$&#39;, payload: 1 }\n// { type: &#39;even$&#39;, payload: 2 }\n// { type: &#39;odd$&#39;, payload: 3 }\n\nconst { even$, odd$ } = splitSources(evenAndOdd$);\n\neven$.subscribe(console.log);\n// { type: &#39;even$&#39;, payload: 0 }\n// { type: &#39;even$&#39;, payload: 2 }\n\nodd$.subscribe(console.log);\n// { type: &#39;odd$&#39;, payload: 1 }\n// { type: &#39;odd$&#39;, payload: 3 }\n</code></pre>\n<h4 id="example-splitting-an-http-source-using-aliases">Example: Splitting an HTTP source using aliases</h4>\n<pre><code class="language-typescript">import { getAction } from &#39;@state-adapt/core&#39;;\nimport { toSource, splitSources } from &#39;@state-adapt/rxjs&#39;;\nimport { ajax } from &#39;rxjs/ajax&#39;;\n\nconst http$ = ajax(&#39;https://jsonplaceholder.typicode.com/todos/1&#39;).pipe(\n  map(res =&gt; ({ type: &#39;todos.success$&#39; as const, payload: res })),\n  catchError(error =&gt; of({ type: &#39;todos.error$&#39; as const, payload: error })),\n);\n\nconst { success$, error$ } = splitSources(http$, {\n  success$: &#39;todos.success$&#39;,\n  error$: &#39;todos.error$&#39;,\n});\n\nsuccess$.subscribe(console.log);\n// { type: &#39;success$&#39;, payload: { ... } }\n\nerror$.subscribe(console.log);\n// { type: &#39;error$&#39;, payload: { ... } }\n</code></pre>\n<h2 id="catcherrorsource"><code>catchErrorSource</code></h2>\n<p>  <code>catchErrorSource</code> is a custom RxJS <a href="https://rxjs.dev/guide/operators">operator</a> that converts an RxJS <a href="https://rxjs.dev/guide/observable">Observable</a>\n  of any values into a source of errors, using RxJS&#39; <a href="https://rxjs.dev/api/operators/catchError">catchError</a> operator.\n  It takes one argument, <code>TypePrefix</code>, and prefixes it to create an object of type <a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/core#action\'})); void(0)"><code>Action</code></a>&lt;any, ${<code>TypePrefix</code>}.error$&gt;.</p>\n<h4 id="example-catching-errors-from-a-source">Example: Catching errors from a source</h4>\n<pre><code class="language-typescript">import { timer, map } from &#39;rxjs&#39;;\n\nconst timer$ = timer(1000).pipe(\n  map(n =&gt; ({ type: &#39;timer$&#39;, payload: n.fakeNumberMethod() })),\n  catchErrorSource(&#39;timer&#39;),\n);\n\ntimer$.subscribe(console.log);\n// { type: &#39;timer.error$&#39;, payload: &#39;Error: n.fakeNumberMethod is not a function&#39; }\n</code></pre>\n<h2 id="tosource"><code>toSource</code></h2>\n<p>  <code>toSource</code> is a custom RxJS <a href="https://rxjs.dev/guide/operators">operator</a> that converts an RxJS <a href="https://rxjs.dev/guide/observable">Observable</a>\n  of values of type <code>Payload</code> (inferred) into an observable of values of type <a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/core#action\'})); void(0)"><code>Action</code></a>&lt;<code>Payload</code>, <code>Type</code>&gt;.\n  It takes one argument, <code>type</code>, which is the <code>type</code> property of the <a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/core#action\'})); void(0)"><code>Action</code></a> objects that will be emitted, and which will\n  appear as the action type in Redux DevTools:</p>\n<p>  <img src="https://state-adapt.github.io/assets/devtools-timer$.png" alt="Action Type in Redux Devtools" /></p>\n<h4 id="example-converting-an-observable-into-a-source-1">Example: Converting an observable into a source</h4>\n<pre><code class="language-typescript">import { timer } from &#39;rxjs&#39;;\nimport { toSource } from &#39;@state-adapt/rxjs&#39;;\n\nconst timer$ = timer(1000).pipe(toSource(&#39;timer$&#39;));\n\ntimer$.subscribe(console.log);\n// { type: &#39;timer$&#39;, payload: 0 }\n</code></pre>\n\x3c!-- cache 21 --\x3e\n\n<h3 id="210">2.1.0</h3>\n<h4 id="source-and-tosource"><code>Source</code> and <code>toSource</code></h4>\n<p><code>Source</code> and <code>toSource</code> have been deprecated and will be removed in 3.0.0 in favor of\n<a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/rxjs#source\'})); void(0)"><code>source</code></a> and <a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/rxjs#type\'})); void(0)"><code>type</code></a>.</p>\n<p>A simple find/replace should work:</p>\n<pre><code class="language-diff-typescript">-new Source\n+source\n</code></pre>\n<pre><code class="language-diff-typescript">-toSource(\n+type(\n</code></pre>\n<p>But these change the structure of the values emitted, and there is no code mod that can handle every breaking change.\nYou will have to rely on TypeScript to highlight issues to fix manually. However, the fixes should be fairly simple:</p>\n<pre><code class="language-diff-typescript">-  const deleteTodo$ = new Source&lt;number&gt;(&#39;deleteTodo$&#39;);\n+  const deleteTodo$ = source&lt;number&gt;(&#39;deleteTodo$&#39;);\n\n  const deleteTodoRequest$ = deleteTodo$.pipe(\n-    exhaustMap(({ payload }) =&gt;\n+    exhaustMap((payload) =&gt;\n      ajax({\n        url: `https://jsonplaceholder.typicode.com/todos/${payload}`,\n        method: &#39;DELETE&#39;,\n      }).pipe(toRequestSource(&#39;todo.delete&#39;))\n// ...\n</code></pre>\n<p>Stores can accept observables of plain values, or, for backwards compatability, if they are wrapped in\n<code>{ type: string; payload: Payload }</code> objects, stores will access the <code>payload</code> property, as before.</p>\n<h3 id="200">2.0.0</h3>\n<p><a href="https://stackblitz.com/edit/vitejs-vite-bca52l?file=src%2FApp.tsx,src%2FtransformCode.ts">Here is a migrator in StackBlitz</a>\nfor automatic migrating. Use Prettier to format the result.</p>\n<p>The 4 overloads of <a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/rxjs#stateadaptadapt\'})); void(0)"><code>StateAdapt.adapt</code></a> have been removed. Here is the new syntax for each overload:</p>\n<h4 id="1-adaptpath-initialstate"><code>1. adapt(path, initialState)</code></h4>\n<pre><code class="language-typescript">// old\nconst count1 = adapt(&#39;count1&#39;, 4);\n\n// new\nconst count1 = adapt(4);\n</code></pre>\n<h4 id="2-adaptpath-initialstate-adapter"><code>2. adapt([path, initialState], adapter)</code></h4>\n<pre><code class="language-typescript">// old\nconst count2_2 = adapt([&#39;count2_2&#39;, 4], {\n  increment: count =&gt; count + 1,\n  selectors: {\n    isEven: count =&gt; count % 2 === 0,\n  },\n});\n\n// new\nconst count2_2 = adapt(4, {\n  increment: count =&gt; count + 1,\n  selectors: {\n    isEven: count =&gt; count % 2 === 0,\n  },\n});\n</code></pre>\n<h4 id="3-adaptpath-initialstate-sources"><code>3. adapt([path, initialState], sources)</code></h4>\n<pre><code class="language-typescript">// old\nconst count3 = adapt(\n  [&#39;count3&#39;, 4],\n  http.get(&#39;/count/&#39;).pipe(toSource(&#39;http data&#39;)),\n);\n\n// new\nconst count3 = adapt(4, {\n  sources: http.get(&#39;/count/&#39;).pipe(toSource(&#39;http data&#39;)),\n});\n</code></pre>\n<h4 id="4-adaptpath-initialstate-adapter-sources"><code>4. adapt([path, initialState, adapter], sources)</code></h4>\n<pre><code class="language-typescript">// old\nconst adapter4 = createAdapter&lt;number&gt;()({\n  increment: count =&gt; count + 1,\n  selectors: {\n    isEven: count =&gt; count % 2 === 0,\n  },\n});\nconst count4 = adapt([&#39;count4&#39;, 4, adapter4], watched =&gt; {\n  return {\n    set: watched.state$.pipe(delay(1000), toSource(&#39;tick$&#39;)),\n  };\n});\n\n// new\nconst count4 = adapt(4, {\n  adapter: {\n    increment: count =&gt; count + 1,\n    selectors: {\n      isEven: count =&gt; count % 2 === 0,\n    },\n  },\n  sources: watched =&gt; {\n    return {\n      set: watched.state$.pipe(delay(1000), toSource(&#39;tick$&#39;)),\n    };\n  },\n  path: &#39;count4&#39;,\n});\n</code></pre>\n<p>See <a href="https://github.com/state-adapt/state-adapt/issues/45">this GitHub issue</a> for the reasons for this change.</p>\n'}}return o.\u0275fac=function(a){return new(a||o)},o.\u0275cmp=e.Xpm({type:o,selectors:[["sa-docs-rxjs"]],standalone:!0,features:[e.jDz],decls:2,vars:1,consts:[[3,"html"]],template:function(a,p){1&a&&(e.TgZ(0,"sa-content"),e._UZ(1,"sa-html",0),e.qZA()),2&a&&(e.xp6(1),e.Q6J("html",p.html))},dependencies:[c.S,r.XB],encapsulation:2}),o})()}}]);