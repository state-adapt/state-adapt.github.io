"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[9],{5009:(o,e,t)=>{t.r(e),t.d(e,{default:()=>n});const n='<h2 id="usestate-without-regrets"><code>useState</code> without regrets</h2>\n<p>Clean state management should be easy.</p>\n<p><code>useState</code> is easy.</p>\n\x3c!-- ```tsx\nfunction SimpleState() {\n  const [name, setName] = useState(\'Bob\');\n  return (\n    <>\n      <h2>Hello {name}!</h2>\n      <button onClick={() => setName(\'Bilbo\')}>Change Name</button>\n    </>\n  );\n}\n``` --\x3e\n\n<p>Developers should feel completely free to use <code>useState</code> for simple features.</p>\n<h2 id="a-smooth-path-to-reducers">A smooth path to reducers</h2>\n<p>But when state needs to change in more complex ways, there are 2 approaches:</p>\n\x3c!-- 1. Event handlers\n2. Reducers --\x3e\n\n<blockquote>\n<p><strong>Event handlers</strong>\u2014scattered state logic \u274c</p>\n</blockquote>\n<blockquote>\n<p><strong>Reducers</strong>\u2014colocated state logic \u2705</p>\n</blockquote>\n<p>But refactoring from <code>useState</code> to <code>useReducer</code> takes a lot of work.</p>\n<p>StateAdapt provides a smoother path to reducers:</p>\n<h3 id="1-replace-usestate-with-useadapt">1. Replace <code>useState</code> with <code>useAdapt</code></h3>\n<pre><code class="language-diff-tsx">function SimpleStateAdapt() {\n-  const [name, setName] = useState(&#39;Bob&#39;);\n+  const [name, setName] = useAdapt(&#39;Bob&#39;);\n  return (\n    &lt; &gt;\n-      &lt;h2&gt;Hello {name}!&lt;/h2&gt;\n+      &lt;h2&gt;Hello {name.state}!&lt;/h2&gt;\n      &lt;button onClick={() =&gt; setName(&#39;Bilbo&#39;)}&gt;Change Name&lt;/button&gt;\n    &lt;/&gt;\n  );\n}\n</code></pre>\n<p>Result:</p>\n<pre><code class="language-tsx">function SimpleStateAdapt() {\n  const [name, setName] = useAdapt(&#39;Bob&#39;);\n  return (\n    &lt;&gt;\n      &lt;h2&gt;Hello {name.state}!&lt;/h2&gt;\n      &lt;button onClick={() =&gt; setName(&#39;Bilbo&#39;)}&gt;Change Name&lt;/button&gt;\n    &lt;/&gt;\n  );\n}\n</code></pre>\n<h3 id="2-add-reducers">2. Add Reducers</h3>\n<pre><code class="language-diff-tsx">function ReducedState() {\n-  const [name, setName] = useAdapt(&#39;Bob&#39;);\n+  const [name, setName] = useAdapt(&#39;Bob&#39;, {\n+    reverse: name =&gt; name.split(&#39;&#39;).reverse().join(&#39;&#39;), // name type inferred\n+  });\n  return (\n    &lt; &gt;\n      &lt;h2&gt;Hello {name.state}!&lt;/h2&gt;\n      &lt;button onClick={() =&gt; setName(&#39;Bilbo&#39;)}&gt;Change Name&lt;/button&gt;\n+      &lt;button onClick={() =&gt; setName.reverse()}&gt;Reverse Name&lt;/button&gt;\n    &lt;/&gt;\n  );\n}\n</code></pre>\n<p>Result:</p>\n<pre><code class="language-tsx">function ReducedState() {\n  const [name, setName] = useAdapt(&#39;Bob&#39;, {\n    reverse: name =&gt; name.split(&#39;&#39;).reverse().join(&#39;&#39;),\n  });\n  return (\n    &lt;&gt;\n      &lt;h2&gt;Hello {name.state}!&lt;/h2&gt;\n      &lt;button onClick={() =&gt; setName(&#39;Bilbo&#39;)}&gt;Change Name&lt;/button&gt;\n      &lt;button onClick={() =&gt; setName.reverse()}&gt;Reverse Name&lt;/button&gt;\n    &lt;/&gt;\n  );\n}\n</code></pre>\n<h2 id="a-smooth-path-to-shared-state">A smooth path to shared state</h2>\n<p>Moving local state to shared state should be easy.</p>\n<p><code>useAdapt</code> easily splits into <code>adapt</code> and <code>useStore</code>:</p>\n<pre><code class="language-diff-tsx">+const nameStore = adapt(&#39;Bob&#39;, {\n+  reverse: name =&gt; name.split(&#39;&#39;).reverse().join(&#39;&#39;),\n+});\n\nfunction SharedState() {\n-  const [name, setName] = useAdapt(&#39;Bob&#39;, {\n-    reverse: name =&gt; name.split(&#39;&#39;).reverse().join(&#39;&#39;),\n-  });\n+  const [name, setName] = useStore(nameStore);\n  return (\n    &lt;&gt;\n      &lt;h2&gt;Hello {name.state}!&lt;/h2&gt;\n      &lt;button onClick={() =&gt; setName(&#39;Bilbo&#39;)}&gt;Change Name&lt;/button&gt;\n      &lt;button onClick={() =&gt; setName.reverse()}&gt;Reverse Name&lt;/button&gt;\n    &lt;/&gt;\n  );\n}\n</code></pre>\n<p>Result:</p>\n<pre><code class="language-tsx">const nameStore = adapt(&#39;Bob&#39;, {\n  reverse: name =&gt; name.split(&#39;&#39;).reverse().join(&#39;&#39;),\n});\n\nfunction SharedState() {\n  const [name, setName] = useStore(nameStore);\n  return (\n    &lt;&gt;\n      &lt;h2&gt;Hello {name.state}!&lt;/h2&gt;\n      &lt;button onClick={() =&gt; setName(&#39;Bilbo&#39;)}&gt;Change Name&lt;/button&gt;\n      &lt;button onClick={() =&gt; setName.reverse()}&gt;Reverse Name&lt;/button&gt;\n    &lt;/&gt;\n  );\n}\n</code></pre>\n\x3c!-- <video controls loop>\n  <source src="./assets/demo-1-simple-state.mov" type="video/mp4"/>\n</video> --\x3e\n\n\x3c!-- ### Try it on [StackBlitz](https://stackblitz.com/edit/vitejs-vite-thndfy?file=src%2F1SimpleState.tsx) --\x3e\n\n<h2 id="a-smooth-path-to-shared-derived-state">A smooth path to shared, derived state</h2>\n<p>Nothing is as easy as derived state in React components:</p>\n<pre><code class="language-tsx">const [name, setName] = useAdapt(nameStore);\n\nconst randomCaseName = name.state\n  .split(&#39;&#39;)\n  .map(c =&gt; (Math.random() &gt; 0.5 ? c : c.toUpperCase()))\n  .join(&#39;&#39;);\n</code></pre>\n<p>Since nothing can match this syntax, anything you do to share this logic with other components will require some refactoring.</p>\n<p>One way StateAdapt addresses this is by allowing selectors to be defined alongside state from the start:</p>\n<pre><code class="language-diff-tsx">function SharedDerivedState() {\n  const [name, setName] = useAdapt(&#39;Bob&#39;, {\n    reverse: name =&gt; name.split(&#39;&#39;).reverse().join(&#39;&#39;),\n+    seletors: {\n+      randomCase: name =&gt;\n+        name\n+          .split(&#39;&#39;)\n+          .map(c =&gt; (Math.random() &gt; 0.5 ? c : c.toUpperCase()))\n+          .join(&#39;&#39;),\n+    },\n  });\n  return (\n    &lt; &gt;\n      &lt;h2&gt;Hello {name.state}!&lt;/h2&gt;\n+      &lt;h2&gt;Hello {name.randomCase}!&lt;/h2&gt;\n      &lt;button onClick={() =&gt; setName(&#39;Bilbo&#39;)}&gt;Change Name&lt;/button&gt;\n      &lt;button onClick={() =&gt; setName.reverse()}&gt;Reverse Name&lt;/button&gt;\n    &lt;/&gt;\n  );\n}\n</code></pre>\n<p>Now if you need to share it, the selectors can just move with the state:</p>\n<pre><code class="language-diff-tsx">+const nameStore = adapt(&#39;Bob&#39;, {\n+  reverse: name =&gt; name.split(&#39;&#39;).reverse().join(&#39;&#39;),\n+  seletors: {\n+      randomCase: name =&gt;\n+        name\n+          .split(&#39;&#39;)\n+          .map(c =&gt; (Math.random() &gt; 0.5 ? c : c.toUpperCase()))\n+          .join(&#39;&#39;),\n+  },\n+});\n\nfunction SharedDerivedState() {\n-  const [name, setName] = useAdapt(&#39;Bob&#39;, {\n-    reverse: name =&gt; name.split(&#39;&#39;).reverse().join(&#39;&#39;),\n-    seletors: {\n-      randomCase: name =&gt;\n-        name\n-          .split(&#39;&#39;)\n-          .map(c =&gt; (Math.random() &gt; 0.5 ? c : c.toUpperCase()))\n-          .join(&#39;&#39;),\n-    },\n-  });\n+  const [name, setName] = useStore(nameStore);\n  return (\n    &lt;&gt;\n      &lt;h2&gt;Hello {name.state}!&lt;/h2&gt;\n      &lt;h2&gt;Hello {name.randomCase}!&lt;/h2&gt;\n      &lt;button onClick={() =&gt; setName(&#39;Bilbo&#39;)}&gt;Change Name&lt;/button&gt;\n      &lt;button onClick={() =&gt; setName.reverse()}&gt;Reverse Name&lt;/button&gt;\n    &lt;/&gt;\n  );\n}\n</code></pre>\n<p>Result:</p>\n<pre><code class="language-tsx">const nameStore = adapt(&#39;Bob&#39;, {\n  reverse: name =&gt; name.split(&#39;&#39;).reverse().join(&#39;&#39;),\n  seletors: {\n    randomCase: name =&gt;\n      name\n        .split(&#39;&#39;)\n        .map(c =&gt; (Math.random() &gt; 0.5 ? c : c.toUpperCase()))\n        .join(&#39;&#39;),\n  },\n});\n\nfunction SharedDerivedState() {\n  const [name, setName] = useStore(nameStore);\n  return (\n    &lt;&gt;\n      &lt;h2&gt;Hello {name.state}!&lt;/h2&gt;\n      &lt;h2&gt;Hello {name.randomCase}!&lt;/h2&gt;\n      &lt;button onClick={() =&gt; setName(&#39;Bilbo&#39;)}&gt;Change Name&lt;/button&gt;\n      &lt;button onClick={() =&gt; setName.reverse()}&gt;Reverse Name&lt;/button&gt;\n    &lt;/&gt;\n  );\n}\n</code></pre>\n<p>But you will sometimes still need to refactor local derived state to shared derived state.</p>\n<p>An AI utility like <a href="https://github.com/features/copilot">Copilot</a> completely solves this for StateAdapt,\nbecause selectors are a widely familiar state management pattern.\nCopilot will see <code>doubleCount</code> below and suggest a correct completion</p>\n<pre><code class="language-diff-tsx">const nameStore = adapt(&#39;Bob&#39;, {\n  reverse: name =&gt; name.split(&#39;&#39;).reverse().join(&#39;&#39;),\n  seletors: {\n-    random \u{1f448} // Trigger Copilot suggestion\n+    randomCase: name =&gt; // Autocompleted by Copilot, with no other context\n+      name\n+        .split(&#39;&#39;)\n+        .map(c =&gt; (Math.random() &gt; 0.5 ? c : c.toUpperCase()))\n+        .join(&#39;&#39;),\n  },\n});\n\nfunction SharedDerivedState() {\n  const [name, setName] = useStore(nameStore);\n-  const randomCaseName = name.state // Now we can delete this down here\n-    .split(&#39;&#39;)\n-    .map(c =&gt; (Math.random() &gt; 0.5 ? c : c.toUpperCase()))\n-    .join(&#39;&#39;);\n  return (\n    &lt;&gt;\n      &lt;h2&gt;Hello {name.state}!&lt;/h2&gt;\n      &lt;h2&gt;Hello {name.randomCase}!&lt;/h2&gt;\n      &lt;button onClick={() =&gt; setName(&#39;Bilbo&#39;)}&gt;Change Name&lt;/button&gt;\n      &lt;button onClick={() =&gt; setName.reverse()}&gt;Reverse Name&lt;/button&gt;\n    &lt;/&gt;\n  );\n}\n</code></pre>\n\x3c!-- The only way to share this logic with multiple components without refactoring is to create a custom hook. But this still takes work, because you need to return everything, and destructure it:\n\n```diff-tsx\n+function useCountWithDouble(initialCount: 0) {\n  const [count, setCount] = useAdapt(0);\n\n  const doubleCount = count.state * 2;\n\n+  return [{ count, doubleCount }, setCount] as const;\n+}\n\n// ...\n\n+  const [{ count, doubleCount }, setCount] = useCountWithDouble(0);\n```\n\nOr you could try creating a hook for just `doubleCount`:\n\n```diff-tsx\n+function useDoubleCount(count: { state: number }) {\n  const doubleCount = count.state * 2;\n+  return doubleCount;\n+}\n\n// ...\n  const [count, setCount] = useAdapt(0);\n\n+  const doubleCount = useDoubleCount(count);\n\n``` --\x3e\n\x3c!--\n```diff-tsx\nconst nameStore = adapt(\'Bob\', {\n  reverse: name => name.split(\'\').reverse().join(\'\'),\n+  selectors: {\n+    yelled: name => name.toUpperCase(), // Will be memoized\n+  },\n});\n\nfunction DerivedState() {\n  const [name, setName] = useStore(nameStore);\n  return (\n    < >\n      <h2>Hello {name.state}!</h2>\n+      <h2>Hello {name.yelled}!</h2>\n      <button onClick={() => setName(\'Bilbo\')}>Change Name</button>\n      <button onClick={() => setName.reverse()}>Reverse Name</button>\n    </>\n  );\n}\n```\n\nResult:\n\n```tsx\nconst nameStore = adapt(\'Bob\', {\n  reverse: name => name.split(\'\').reverse().join(\'\'),\n  selectors: {\n    yelled: name => name.toUpperCase(), // Will be memoized\n  },\n});\n\nfunction SharedDerivedState() {\n  const [name, setName] = useStore(nameStore);\n  return (\n    <>\n      <h2>Hello {name.state}!</h2>\n      <h2>Hello {name.yelled}!</h2>\n      <button onClick={() => setName(\'Bilbo\')}>Change Name</button>\n      <button onClick={() => setName.reverse()}>Reverse Name</button>\n    </>\n  );\n}\n```\n\n<video controls loop>\n  <source src="./assets/demo-2-derived-state.mov" type="video/mp4" />\n</video>\n\n### Try it on [StackBlitz](https://stackblitz.com/edit/vitejs-vite-thndfy?file=src%2F2DerivedState.tsx) --\x3e\n\n\x3c!-- ## 3. Define state changes declaratively in stores\n\nMaintain separation of concerns by keeping state logic together instead of scattered.\n\n```diff-tsx\n const nameStore = adapt(\'Bob\', {\n+  reverse: name => name.split(\'\').reverse().join(\'\'),\n  selectors: {\n    yelled: name => name.toUpperCase(), // Will be memoized\n  },\n});\n\nfunction SharedState() {\n  const [name] = useStore(nameStore);\n  return (\n    < >\n      <h2>Hello {name.yelled}!</h2>\n      <button onClick={() => setName(\'Bilbo\')}>Change Name</button>\n+      <button onClick={() => setName.reverse()}>Reverse Name</button>\n    </>\n  );\n}\n```\n\n<video controls loop>\n  <source src="./assets/demo-3-state-changes.mov" type="video/mp4" />\n</video>\n\n### Try it on [StackBlitz](https://stackblitz.com/edit/vitejs-vite-thndfy?file=src%2F3StateChanges.tsx) --\x3e\n\n<h2 id="a-smooth-path-to-state-logic-reuse">A smooth path to state logic reuse</h2>\n<p>State logic that references <a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/react#a-smooth-path-to-reactive-state\'})); void(0)">specific event sources</a> and state requires major refactoring if multiple states end up needing it.</p>\n<p>State adapters provide a smooth path to extracting logic away from specific event sources and state:</p>\n<pre><code class="language-diff-tsx">-const nameStore = adapt(&#39;Bob&#39;, {\n+const nameAdapter = createAdapter&lt;string&gt;()({\n  reverse: name =&gt; name.split(&#39;&#39;).reverse().join(&#39;&#39;),\n  selectors: {\n    randomCase: name =&gt;\n      name\n        .split(&#39;&#39;)\n        .map(c =&gt; (Math.random() &gt; 0.5 ? c : c.toUpperCase()))\n        .join(&#39;&#39;),\n  },\n});\n+const name1Store = adapt(&#39;Bob&#39;, nameAdapter);\n+const name2Store = adapt(&#39;Kat&#39;, nameAdapter);\n\n// ...\n</code></pre>\n<p>Result:</p>\n<pre><code class="language-tsx">const nameAdapter = createAdapter&lt;string&gt;()({\n  reverse: name =&gt; name.split(&#39;&#39;).reverse().join(&#39;&#39;),\n  selectors: {\n    randomCase: name =&gt;\n      name\n        .split(&#39;&#39;)\n        .map(c =&gt; (Math.random() &gt; 0.5 ? c : c.toUpperCase()))\n        .join(&#39;&#39;),\n  },\n});\nconst name1Store = adapt(&#39;Bob&#39;, nameAdapter);\nconst name2Store = adapt(&#39;Kat&#39;, nameAdapter);\n\nfunction StateAdapters() {\n  const [name1, setName1] = useStore(name1Store);\n  const [name2, setName2] = useStore(name2Store);\n  return (\n    &lt;&gt;\n      &lt;h2&gt;Hello {name1.state}!&lt;/h2&gt;\n      &lt;h2&gt;Hello {name1.randomCase}!&lt;/h2&gt;\n      &lt;button onClick={() =&gt; setName1(&#39;Bilbo&#39;)}&gt;Change Name&lt;/button&gt;\n      &lt;button onClick={() =&gt; setName1.reverse()}&gt;Reverse Name&lt;/button&gt;\n\n      &lt;h2&gt;Hello {name2.state}!&lt;/h2&gt;\n      &lt;h2&gt;Hello {name2.randomCase}!&lt;/h2&gt;\n      &lt;button onClick={() =&gt; setName2(&#39;Bilbo&#39;)}&gt;Change Name&lt;/button&gt;\n      &lt;button onClick={() =&gt; setName2.reverse()}&gt;Reverse Name&lt;/button&gt;\n    &lt;/&gt;\n  );\n}\n</code></pre>\n\x3c!-- <video controls loop>\n  <source src="./assets/demo-4-state-adapters.mov" type="video/mp4" />\n</video>\n\n### Try it on [StackBlitz](https://stackblitz.com/edit/vitejs-vite-thndfy?file=src%2F4StateAdapters.tsx) --\x3e\n\n<h2 id="a-smooth-path-to-reactive-state">A smooth path to reactive state</h2>\n<p>When multiple states need to change after an event, there are 2 approaches:</p>\n<blockquote>\n<p><strong>Event handlers updating multiple states</strong>\u2014scattered state changes \u274c</p>\n</blockquote>\n<blockquote>\n<p><strong>States reacting to events</strong>\u2014colocated state changes \u2705</p>\n</blockquote>\n<p>But refactoring to a typical event-driven state management library takes a lot of work.</p>\n<p>StateAdapt provides a smooth path to allow stores to react to events:</p>\n<pre><code class="language-diff-tsx">// ...\n\n+const onResetAll = source(); // Event source\n\n-const name1Store = adapt(&#39;Bob&#39;, nameAdapter);\n+const name1Store = adapt(&#39;Bob&#39;, {\n+  adapter: nameAdapter,\n+  sources: { reset: onResetAll }, // calls `reset` reducer (included)\n+});\n-const name2Store = adapt(&#39;Kat&#39;, nameAdapter);\n+const name2Store = adapt(&#39;Kat&#39;, {\n+  adapter: nameAdapter,\n+  sources: { reset: onResetAll }, // calls `reset` reducer (included)\n+});\n\n// ...\n\n+      &lt;button onClick={onResetAll}&gt;Reset All&lt;/button&gt;\n    &lt;/&gt;\n  );\n}\n</code></pre>\n<p>Result:</p>\n<pre><code class="language-tsx">const nameAdapter = createAdapter&lt;string&gt;()({\n  reverse: name =&gt; name.split(&#39;&#39;).reverse().join(&#39;&#39;),\n  selectors: {\n    randomCase: name =&gt;\n      name\n        .split(&#39;&#39;)\n        .map(c =&gt; (Math.random() &gt; 0.5 ? c : c.toUpperCase()))\n        .join(&#39;&#39;),\n  },\n});\n\nconst onResetAll = source();\n\nconst name1Store = adapt(&#39;Bob&#39;, {\n  adapter: nameAdapter,\n  sources: { reset: onResetAll },\n});\nconst name2Store = adapt(&#39;Kat&#39;, {\n  adapter: nameAdapter,\n  sources: { reset: onResetAll },\n});\n\nfunction ReactiveState() {\n  const [name1, setName1] = useStore(name1Store);\n  const [name2, setName2] = useStore(name2Store);\n  return (\n    &lt;&gt;\n      &lt;h2&gt;Hello {name1.state}!&lt;/h2&gt;\n      &lt;h2&gt;Hello {name1.randomCase}!&lt;/h2&gt;\n      &lt;button onClick={() =&gt; setName1(&#39;Bilbo&#39;)}&gt;Change Name&lt;/button&gt;\n      &lt;button onClick={() =&gt; setName1.reverse()}&gt;Reverse Name&lt;/button&gt;\n\n      &lt;h2&gt;Hello {name2.state}!&lt;/h2&gt;\n      &lt;h2&gt;Hello {name2.randomCase}!&lt;/h2&gt;\n      &lt;button onClick={() =&gt; setName2(&#39;Bilbo&#39;)}&gt;Change Name&lt;/button&gt;\n      &lt;button onClick={() =&gt; setName2.reverse()}&gt;Reverse Name&lt;/button&gt;\n\n      &lt;button onClick={onResetAll}&gt;Reset All&lt;/button&gt;\n    &lt;/&gt;\n  );\n}\n</code></pre>\n\x3c!-- <video controls loop>\n  <source src="./assets/demo-5-observable-sources.mov" type="video/mp4" />\n</video>\n\n### Try it on [StackBlitz](https://stackblitz.com/edit/vitejs-vite-thndfy?file=src%2F5ObservableSources.tsx) --\x3e\n\n<h2 id="a-smooth-path-to-multi-store-shared-derived-states">A smooth path to multi-store, shared, derived states</h2>\n<p>State derived from multiple stores can <a href="https://dev.to/mfp22/signals-make-angular-much-easier-3k9">glitch and over-compute</a> in some libraries, especially if RxJS-based.</p>\n<p>But StateAdapt&#39;s <code>joinStores</code> is glitch-free and efficient, preventing the need for complicated workarounds and refactors:</p>\n<pre><code class="language-diff-tsx">// ...\n\n+const name12Store = joinStores({\n+  name1: name1Store,\n+  name2: name2Store,\n+})({\n+  bobcat: s =&gt; s.name1 === &#39;Bob&#39; &amp;&amp; s.name2 === &#39;Kat&#39;\n+})();\n\n// ...\n\n+  const [{ bobcat }] = useStore(name12Store);\n\n  // ...\n\n+      {bobcat &amp;&amp; &lt;h2&gt;Hello, bobcat!&lt;/h2&gt;}\n    &lt;/&gt;\n  );\n}\n</code></pre>\n<p>Result:</p>\n<pre><code class="language-tsx">const nameAdapter = createAdapter&lt;string&gt;()({\n  reverse: name =&gt; name.split(&#39;&#39;).reverse().join(&#39;&#39;),\n  selectors: {\n    randomCase: name =&gt;\n      name\n        .split(&#39;&#39;)\n        .map(c =&gt; (Math.random() &gt; 0.5 ? c : c.toUpperCase()))\n        .join(&#39;&#39;),\n  },\n});\n\nconst onResetAll = source();\n\nconst name1Store = adapt(&#39;Bob&#39;, {\n  adapter: nameAdapter,\n  sources: { reset: onResetAll },\n});\nconst name2Store = adapt(&#39;Kat&#39;, {\n  adapter: nameAdapter,\n  sources: { reset: onResetAll },\n});\n\nconst name12Store = joinStores({\n  name1: name1Store,\n  name2: name2Store,\n})({\n  bobcat: s =&gt; s.name1 === &#39;Bob&#39; &amp;&amp; s.name2 === &#39;Kat&#39;,\n})();\n\nfunction MultiStoreSharedDerivedState() {\n  const [name1, setName1] = useStore(name1Store);\n  const [name2, setName2] = useStore(name2Store);\n  const [{ bobcat }] = useStore(name12Store);\n  return (\n    &lt;&gt;\n      &lt;h2&gt;Hello {name1.state}!&lt;/h2&gt;\n      &lt;h2&gt;Hello {name1.randomCase}!&lt;/h2&gt;\n      &lt;button onClick={() =&gt; setName1(&#39;Bilbo&#39;)}&gt;Change Name&lt;/button&gt;\n      &lt;button onClick={() =&gt; setName1.reverse()}&gt;Reverse Name&lt;/button&gt;\n\n      &lt;h2&gt;Hello {name2.state}!&lt;/h2&gt;\n      &lt;h2&gt;Hello {name2.randomCase}!&lt;/h2&gt;\n      &lt;button onClick={() =&gt; setName2(&#39;Bilbo&#39;)}&gt;Change Name&lt;/button&gt;\n      &lt;button onClick={() =&gt; setName2.reverse()}&gt;Reverse Name&lt;/button&gt;\n\n      &lt;button onClick={onResetAll}&gt;Reset All&lt;/button&gt;\n\n      {bobcat &amp;&amp; &lt;h2&gt;Hello, bobcat!&lt;/h2&gt;}\n    &lt;/&gt;\n  );\n}\n</code></pre>\n\x3c!-- ```diff-tsx\n const nameAdapter = createAdapter<string>()({\n  reverse: name => name.split(\'\').reverse().join(\'\'),\n  concatName: (name, anotherName: string) => `${name} ${anotherName}`,\n  selectors: {\n    yelled: name => name.toUpperCase(), // Will be memoized\n  },\n});\n\nconst onNameFromServer = timer(3000).pipe(\n  mapTo(\'Joel\'),\n  toSource(\'[name] onNameFromServer\'), // Annotate for Redux Devtools\n);\n\n+const onResetBoth = source(\'[name] onResetBoth\'); // Annotate for Redux Devtools\n\nconst name1Store = adapt(\'Bob\', {\n  adapter: nameAdapter,\n-   sources: onNameFromServer, // Set state\n+   sources: {\n+     set: onNameFromServer, // `set` is provided with all adapters\n+     reset: onResetBoth, // `reset` is provided with all adapters\n+   },\n});\nconst name2Store = adapt(\'Bob\', {\n  adapter: nameAdapter,\n   sources: {\n     concatName: onNameFromServer, // Trigger a specific state reaction\n+     reset: onResetBoth, // `reset` is provided with all adapters\n   },\n});\n\nfunction SharedSources() {\n  const [name1] = useStore(name1Store);\n  const [name2] = useStore(name2Store);\n  return (\n    <>\n      <h2>Hello {name1.yelled}!</h2>\n      <button onClick={() => name1Store.set(\'Bilbo\')}>Change Name</button>\n      <button onClick={() => name1Store.reverse()}>Reverse Name</button>\n\n      <h1>Hello { name2.yelled }!</h1>\n      <button onClick={() => name2Store.set(\'Bilbo\')}>Change Name</button>\n      <button onClick={() => name2Store.reverse()}>Reverse Name</button>\n\n+      <button onClick={onResetBoth}>Reset Both</button>\n    </>\n  );\n}\n``` --\x3e\n\n\x3c!-- <video controls loop>\n  <source src="./assets/demo-6-dom-sources.mov" type="video/mp4" />\n</video>\n\n### Try it on [StackBlitz](https://stackblitz.com/edit/vitejs-vite-thndfy?file=src%2F6DomSources.tsx) --\x3e\n\n<h2 id="a-smooth-path-to-derived-events">A smooth path to derived events</h2>\n<p>RxJS is the only way to smoothly scale to complex event-driven features.</p>\n<p>StateAdapt sources extend RxJS observables, and StateAdapt stores directly reference RxJS observables and react to their emissions:</p>\n<pre><code class="language-diff-tsx">// ...\n\n-const name1Store = adapt(&#39;Bob&#39;, {\n+const name1Store = adapt(&#39;Loading...&#39;, {\n  adapter: nameAdapter,\n-  sources: { reset: onResetAll },\n+  sources: {\n+    set: of(&#39;Bob&#39;).pipe(delay(3000)), // Any observable\n+    reset: onResetAll,\n+  },\n});\n-const name2Store = adapt(&#39;Kat&#39;, {\n+const name2Store = adapt(&#39;Loading...&#39;, {\n  adapter: nameAdapter,\n-  sources: { reset: onResetAll },\n+  sources: {\n+    set: of(&#39;Kat&#39;).pipe(delay(3000)), // Any observable\n+    reset: onResetAll,\n+  },\n});\n\n// ...\n</code></pre>\n<p>Result:</p>\n<pre><code class="language-tsx">const nameAdapter = createAdapter&lt;string&gt;()({\n  reverse: name =&gt; name.split(&#39;&#39;).reverse().join(&#39;&#39;),\n  selectors: {\n    randomCase: name =&gt;\n      name\n        .split(&#39;&#39;)\n        .map(c =&gt; (Math.random() &gt; 0.5 ? c : c.toUpperCase()))\n        .join(&#39;&#39;),\n  },\n});\n\nconst onResetAll = source();\n\nconst name1Store = adapt(&#39;Loading...&#39;, {\n  adapter: nameAdapter,\n  sources: {\n    set: of(&#39;Bob&#39;).pipe(delay(3000)),\n    reset: onResetAll,\n  },\n});\nconst name2Store = adapt(&#39;Loading...&#39;, {\n  adapter: nameAdapter,\n  sources: {\n    set: of(&#39;Kat&#39;).pipe(delay(3000)),\n    reset: onResetAll,\n  },\n});\n\nconst name12Store = joinStores({\n  name1: name1Store,\n  name2: name2Store,\n})({\n  bobcat: s =&gt; s.name1 === &#39;Bob&#39; &amp;&amp; s.name2 === &#39;Kat&#39;,\n})();\n\nfunction DerivedEvents() {\n  const [name1, setName1] = useStore(name1Store);\n  const [name2, setName2] = useStore(name2Store);\n  const [{ bobcat }] = useStore(name12Store);\n  return (\n    &lt;&gt;\n      &lt;h2&gt;Hello {name1.state}!&lt;/h2&gt;\n      &lt;h2&gt;Hello {name1.randomCase}!&lt;/h2&gt;\n      &lt;button onClick={() =&gt; setName1(&#39;Bilbo&#39;)}&gt;Change Name&lt;/button&gt;\n      &lt;button onClick={() =&gt; setName1.reverse()}&gt;Reverse Name&lt;/button&gt;\n\n      &lt;h2&gt;Hello {name2.state}!&lt;/h2&gt;\n      &lt;h2&gt;Hello {name2.randomCase}!&lt;/h2&gt;\n      &lt;button onClick={() =&gt; setName2(&#39;Bilbo&#39;)}&gt;Change Name&lt;/button&gt;\n      &lt;button onClick={() =&gt; setName2.reverse()}&gt;Reverse Name&lt;/button&gt;\n\n      &lt;button onClick={onResetAll}&gt;Reset All&lt;/button&gt;\n\n      {bobcat &amp;&amp; &lt;h2&gt;Hello, bobcat!&lt;/h2&gt;}\n    &lt;/&gt;\n  );\n}\n</code></pre>\n\x3c!-- const [onResetAllSuccess, onResetAllError] = partition(\n  onResetAllResponse,\n  res => \'error\' in res,\n); --\x3e\n\n<h2 id="automatic-state-lifecycle">Automatic State Lifecycle</h2>\n<p>For state to be truly reactive, it cannot rely on external control code, including initialization and cleanup code.</p>\n<p>StateAdapt stores know when they are being used, and automatically initialize and cleanup their state.</p>\n<p>So, for this store:</p>\n<pre><code class="language-tsx">const name1Store = adapt(&#39;Loading...&#39;, {\n  sources: of(&#39;Bob&#39;).pipe(delay(3000)),\n});\n</code></pre>\n<p>When this component mounts:</p>\n<pre><code class="language-tsx">function AutomaticStateLifecycle() {\n  const [name1, setName1] = useStore(name1Store);\n  // ...\n</code></pre>\n<p>Only then will the state be initialized with <code>Loading...</code> and the observable created by <code>of(&#39;Bob&#39;).pipe(delay(3000))</code> receive a subscription.\nAfter 3 seconds, the name will change to <code>&#39;Bob&#39;</code>.</p>\n<p>Then, when <code>AutomaticStateLifecycle</code> unmounts, as long as no other components are using <code>name1Store</code>, the state will be cleared.</p>\n<p>Then, when <code>AutomaticStateLifecycle</code> mounts again, the state will be re-initialized to <code>&#39;Loading...&#39;</code>,\nthe observable created with <code>of(&#39;Bob&#39;).pipe(delay(3000))</code> will be subscribed to again,\nand after 3 seconds the name will change to <code>&#39;Bob&#39;</code> again.</p>\n<p>In situations where you want to keep the store permanently active, you can manually subscribe to its <code>state$</code>:</p>\n<pre><code class="language-diff-tsx">const name1Store = adapt(&#39;Loading...&#39;, {\n  sources: of(&#39;Bob&#39;).pipe(delay(3000)),\n});\n+name1Store.state$.subscribe();\n</code></pre>\n'}}]);