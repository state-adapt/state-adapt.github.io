"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[830],{6830:(l,a,t)=>{t.r(a),t.d(a,{ConceptsOverviewComponent:()=>u});var o=t(5927),c=t(8176),i=t(2309),e=t(4650);let u=(()=>{class s{constructor(){this.md="# StateAdapt Conceptual Overview\n\nStateAdapt has 3 main concepts: Sources, adapters and stores.\n\n## [Sources](/concepts/sources)\n\n[Sources](/concepts/sources) are where asynchronous data enters applications. Examples are\n\n- User input\n- Data arriving from a server\n- A timer completing\n\n## [Adapters](/concepts/adapters)\n\n[Adapters](/concepts/adapters) are objects containing 2 kinds of reusable state management patterns:\n\n- State changes (pure functions that implement ways state can change)\n- Selectors (pure functions that calculate derived state or just return a specific piece of state)\n\n## [Stores](/concepts/stores)\n\n[Stores](/concepts/stores) do 4 things:\n\n- Define initial state and an adapter to manage it\n- Connect sources to adapter state changes\n- Use the adapter's selectors to create observables of the selectors' results. These observables chain off the sources so subscriptions are propagated\n- Use the adapter's state changes to create synthetic sources for simple, single-store state changes. These are made available as part of the store, so DOM event handlers can call them. See [Synthetic Sources](/concepts/sources#synthetic-sources).\n"}}return s.\u0275fac=function(n){return new(n||s)},s.\u0275cmp=e.Xpm({type:s,selectors:[["state-adapt-concepts-overview"]],standalone:!0,features:[e.jDz],decls:5,vars:1,consts:[[3,"data"],["routerLink","/concepts/sources"]],template:function(n,d){1&n&&(e.TgZ(0,"state-adapt-content"),e._UZ(1,"markdown",0),e.TgZ(2,"h2")(3,"a",1),e._uU(4,"Next: Sources"),e.qZA()()()),2&n&&(e.xp6(1),e.Q6J("data",d.md))},dependencies:[o.Bz,o.yS,i.S,c.JP,c.lF],encapsulation:2}),s})()}}]);