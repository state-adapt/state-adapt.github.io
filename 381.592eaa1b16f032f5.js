"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[381],{6381:(l,o,t)=>{t.r(o),t.d(o,{DocsCoreComponent:()=>d});var r=t(1917),i=t(2309),e=t(4650);let d=(()=>{class a{constructor(){this.html='<h1 id="state-adaptcore">@state-adapt/core</h1>\n<p><a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/core#adapter\'})); void(0)"><code>Adapter</code></a></p>\n<p><a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/core#createadapter\'})); void(0)"><code>createAdapter</code></a></p>\n<p><a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/core#buildadapter\'})); void(0)"><code>buildAdapter</code></a></p>\n<p><a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/core#joinadapters\'})); void(0)"><code>joinAdapters</code></a></p>\n<p><a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/core#action\'})); void(0)"><code>Action</code></a></p>\n<p><a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/core#getaction\'})); void(0)"><code>getAction</code></a></p>\n<p><a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/core#getid\'})); void(0)"><code>getId</code></a></p>\n<h2 id="adapter"><code>Adapter</code></h2>\n<p>  <code>Adapter</code> is a type of object containing 2 kinds of reusable state management patterns: State changes and selectors.</p>\n<p>  State change functions are pure functions that implement ways state can change. They take 3 arguments and return a new state:</p>\n<pre><code class="language-typescript">(\n  state, // Current state\n  payload, // Data needed to calculate new state\n  initialState, // State the adapter was initialized with\n) =&gt; ({ ...state }), // New state\n</code></pre>\n<p>  Selectors are pure functions that calculate derived state or just return a specific piece of state. They take one argument (<code>State</code>) and return any type:</p>\n<pre><code class="language-typescript">state =&gt; state.property,\n</code></pre>\n<h4 id="example-basic-adapter">Example: Basic adapter</h4>\n<pre><code class="language-typescript">import { Adapter } from &#39;@state-adapt/core&#39;;\ntype State = number;\n\nconst adapter = {\n  set: (state: State, payload: State) =&gt; payload,\n  reset: (state: State, payload: any, initialState: State) =&gt; initialState,\n  selectors: {\n    state: (state: State) =&gt; state,\n  },\n} satisfies Adapter&lt;State, any, any&gt;;\n</code></pre>\n<h2 id="createadapter"><code>createAdapter</code></h2>\n<p>  <code>createAdapter</code> is a function that takes an <a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/core#adapter\'})); void(0)"><code>Adapter</code></a> object and returns a new <a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/core#adapter\'})); void(0)"><code>Adapter</code></a> object with the following state change functions added:</p>\n<ul class="bx--list--unordered"><li class="bx--list__item"><code>set</code>: A reaction that sets the state to the payload</li><li class="bx--list__item"><code>reset</code>: A reaction that sets the state to the initial state</li></ul><p>  Every adapter also comes with a default selector:</p>\n<ul class="bx--list--unordered"><li class="bx--list__item"><code>state</code> returns the top-level state value</li></ul><h4 id="example-empty-initial-adapter-object">Example: Empty initial adapter object</h4>\n<pre><code class="language-typescript">import { createAdapter } from &#39;@state-adapt/core&#39;;\n\nconst numberAdapter = createAdapter&lt;number&gt;()({});\n</code></pre>\n<h4 id="example-small-initial-adapter-object">Example: Small initial adapter object</h4>\n<pre><code class="language-typescript">import { createAdapter } from &#39;@state-adapt/core&#39;;\n\nconst numberAdapter = createAdapter&lt;number&gt;()({\n  add: (state, n: number) =&gt; state + n,\n  subtract: (state, n: number) =&gt; state - n,\n  selectors: {\n    negative: state =&gt; state * -1,\n  },\n});\n</code></pre>\n<h4 id="example-initial-adapter-object-with-complex-state">Example: Initial adapter object with complex state</h4>\n<pre><code class="language-typescript">import { createAdapter } from &#39;@state-adapt/core&#39;;\n\ninterface ComplexState {\n  count: number;\n  name: string;\n}\n\nconst complexAdapter = createAdapter&lt;ComplexState&gt;()({\n  increment: state =&gt; ({ ...state, count: state.count + 1 }),\n  decrement: state =&gt; ({ ...state, count: state.count - 1 }),\n  setName: (state, name: string) =&gt; ({ ...state, name }),\n  selectors: {\n    negative: state =&gt; state.count * -1,\n  },\n});\n</code></pre>\n<h2 id="buildadapter"><code>buildAdapter</code></h2>\n<p>  <code>buildAdapter</code> is called with an initial adapter, then can be called again and again with more objects inheriting from previous objects,\n  until a final empty call <code>()</code> to get the final built adapter:</p>\n<pre><code class="language-typescript">import { buildAdapter } from &#39;@state-adapt/core&#39;;\nimport { numberAdapter } from &#39;./number.adapter&#39;;\n\nconst numberStringAdapter = buildAdapter&lt;number&gt;()(numberAdapter)({\n  // Define more stuff\n})(([selectors, reactions]) =&gt; ({\n  // Define more stuff\n}))({\n  // etc\n})(); // End\n</code></pre>\n<p>  The first call creates a new object, but after that, every object passed in is looped over and used to mutate the original new object.</p>\n<p>  <a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/concepts/adapters#buildadapter\'})); void(0)"><code>buildAdapter</code></a> takes 3 possible arguments in each call (after the first):</p>\n<ul class="bx--list--ordered"><li class="bx--list__item">A selectors object</li><li class="bx--list__item">A function taking in a tuple of <code>[selectors, reactions]</code> and returning new reactions</li><li class="bx--list__item">A nested object defining grouped state reactions</li></ul><h3 id="1-selectors">1. Selectors</h3>\n<p>  <a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/concepts/adapters#buildadapter\'})); void(0)"><code>buildAdapter</code></a> provides full selector memoization and a default <code>state</code> selector (after the first call).\n  The selectors defined in the first call each receive a state object to select against. Each subsequent selector block has access to all\n  selectors previously defined. To return all the selectors combined into an adapter, call it a final time with no parameter.</p>\n<h4 id="example-basic-selectors">Example: Basic selectors</h4>\n<pre><code class="language-typescript">import { buildAdapter } from &#39;@state-adapt/core&#39;;\n\nconst stringAdapter = buildAdapter&lt;string&gt;()({})({\n  reverse: s =&gt; s.state.split(&#39;&#39;).reverse().join(&#39;&#39;),\n})({\n  isPalendrome: s =&gt; s.reverse === s.state,\n})();\n</code></pre>\n<p>  <code>s</code> is typed as an object with properties with the same names as all the selectors defined previously, and typed with each corresponding selector&#39;s\n  return type. Internally, <a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/concepts/adapters#buildadapter\'})); void(0)"><code>buildAdapter</code></a> uses a <code>Proxy</code> to detect which selectors your new selector functions are\n  accessing in order memoize them efficiently.</p>\n<h3 id="2-reactions">2. Reactions</h3>\n<h4 id="example-basic-reactions">Example: Basic Reactions</h4>\n<pre><code class="language-typescript">import { buildAdapter } from &#39;@state-adapt/core&#39;;\nimport { numberAdapter } from &#39;./number.adapter&#39;;\n\nconst numberStringAdapter = buildAdapter&lt;number&gt;()(numberAdapter)({\n  negativeStr: s =&gt; s.negative.toString(),\n})(([selectors, reactions]) =&gt; ({\n  setToNegative: state =&gt; selectors.negative(state),\n}))();\n</code></pre>\n<p>  <code>setToNegative</code> becomes a reaction on <code>numberStringAdapter</code> that multiplies the state by <code>-1</code> (the return of <code>selectors.negative(state)</code>).</p>\n<p>  Selectors used when defining new reactions must be called as functions and will not be memoized. If efficiency is critical, you might want to put the derived state in the action payload for the state change.</p>\n<h3 id="3-grouped-reactions">3. Grouped Reactions</h3>\n<p>  The nested object defining grouped state reactions is for nested states. In the following example, a group state reaction called <code>setBothNumbers</code> will set both <code>coolNumber</code> and <code>weirdNumber</code> to the same payload passed into the new <code>setBothNumbers</code> reaction.</p>\n<h4 id="example-grouped-reactions">Example: Grouped Reactions</h4>\n<pre><code class="language-typescript">const numbersAdapter = buildAdapter&lt;NumbersState&gt;()({\n  setCoolNumber: (state, newCoolNumber: number) =&gt; ({\n    ...state,\n    coolNumber: newCoolNumber,\n  }),\n  setWeirdNumber: (state, newWeirdNumber: number) =&gt; ({\n    ...state,\n    weirdNumber: newWeirdNumber,\n  }),\n})({\n  setBothNumbers: {\n    coolNumber: numberAdapter.set,\n    weirdNumber: numberAdapter.set,\n  },\n})();\n</code></pre>\n<p>  The new reaction&#39;s payload type will be the intersection of the payload types from the reactions used, except when one of the payloads is <code>void</code>, in which case it will be ignored in the payload intersection.</p>\n<h2 id="joinadapters"><code>joinAdapters</code></h2>\n<p>  <a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/core#joinadapters\'})); void(0)"><code>joinAdapters</code></a> creates a complex adapter from simpler adapters by taking each of their state change\n  functions and selectors and adding them to the new adapter with more specific names to distinguish them from\n  each other. All state reaction names have their adapter&#39;s namespaces inserted after the first word, and all selector names\n  get prepended with their adapter&#39;s namespace.</p>\n<p>  The initial <a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/core#joinadapters\'})); void(0)"><code>joinAdapters</code></a> call returns the same thing as the <a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/core#buildadapter\'})); void(0)"><code>buildAdapter</code></a> call, so it can be called again and again with more objects inheriting from previous objects, until a final empty call <code>()</code> to get the final built adapter.</p>\n<h4 id="example-basic-joinadapters">Example: Basic <code>joinAdapters</code></h4>\n<pre><code class="language-tsx">import { joinAdapters, createAdapter } from &#39;@state-adapt/core&#39;;\n\ninterface State {\n  a: number;\n  b: number;\n}\n\nconst adapter = joinAdapters&lt;NumbersState&gt;()({\n  a: createAdapter&lt;number&gt;()({}),\n  b: createAdapter&lt;number&gt;()({\n    setTo0: state =&gt; 0,\n    selectors: {\n      negative: state =&gt; state * -1,\n    },\n  }),\n})();\n</code></pre>\n<p>  This is the same as:</p>\n<pre><code class="language-tsx">import { createAdapter } from &#39;@state-adapt/core&#39;;\n\ninterface State {\n  a: number;\n  b: number;\n}\n\nconst adapter = createAdapter&lt;State&gt;()({\n  setA: (state, newA: number) =&gt; ({...state, a: newA}),\n  resetA: (state, payload: void, initialState) =&gt; ({...state, a: initialState.a}),\n  setBTo0: (state, payload: void) =&gt; ({...state, b: 0}),\n  setB: (state, newB: number) =&gt; ({...state, b: newB}),\n  resetB: (state, payload: void, initialState) =&gt; ({...state, b: initialState.b}),\n  set: (state, newState: State) =&gt; newState,\n  reset: (state, payload: void, initialState) =&gt; initialState,\n  update: (state, newState: Partial&lt;State&gt;) =&gt; ({...state, ...newState}),\n  selectors: {\n    a: state =&gt; state.a,\n    b: state =&gt; state.b,\n    bNegative: state =&gt; state.b * -1,\n    state: state =&gt; state,\n  },\n});\n</code></pre>\n<h4 id="example-joinadapters-with-buildadapters-like-syntax">Example: <code>joinAdapters</code> with <code>buildAdapters</code>-like syntax</h4>\n<pre><code class="language-tsx">import { joinAdapters, createAdapter } from &#39;@state-adapt/core&#39;;\nimport { numberAdapter } from &#39;./number.adapter&#39;;\n\ninterface NumbersState {\n  a: number;\n  b: number;\n}\n\nconst adapter = joinAdapters&lt;NumbersState&gt;()({\n  a: numberAdapter,\n  b: numberAdapter,\n})({\n  // Selectors\n  total: s =&gt; s.a + s.b,\n})({\n  // Group reactions\n  incrementAll: {\n    a: numberAdapter.increment,\n    b: numberAdapter.increment,\n  },\n})(([selectors, reactions]) =&gt; ({\n  // More reactions\n  addBToA: state =&gt; ({ ...state, a: selectors.b(state) }),\n  addAToB: state =&gt; ({ ...state, b: selectors.a(state) }),\n}))();\n</code></pre>\n<p>  For more details, see <code>buildAdapters</code>.</p>\n<h4 id="example-auth">Example: Auth</h4>\n<pre><code class="language-tsx">import { joinAdapters, createAdapter } from &#39;@state-adapt/core&#39;;\n\ninterface AuthState {\n  username: string | null;\n  password: string | null;\n  isLoggedIn: boolean;\n}\n\nconst authAdapter = joinAdapters&lt;AuthState&gt;()({\n  username: createAdapter&lt;string | null&gt;()({}),\n  password: createAdapter&lt;string | null&gt;()({}),\n  isLoggedIn: createAdapter&lt;boolean&gt;()({\n    login: () =&gt; true,\n    logout: () =&gt; false,\n  }),\n})();\n\n// Usage\nconst initialState = { username: null, password: null, isLoggedIn: false };\nconst newState = authAdapter.update(initialState, {\n  username: &#39;bob&#39;,\n  password: &#39;1234&#39;,\n});\n// { username: &#39;bob&#39;, password &#39;1234&#39;, isLoggedIn: false }\n</code></pre>\n<h4 id="example-cookies">Example: Cookies</h4>\n<pre><code class="language-tsx">import { joinAdapters, createAdapter } from &#39;@state-adapt/core&#39;;\n\ninterface CookieState {\n  price: number;\n  flavor: &#39;Chocolate Chip&#39; | &#39;Oatmeal Raisin&#39;;\n}\n\nconst cookieAdapter = joinAdapters&lt;CookieState&gt;()({\n  price: createAdapter&lt;number&gt;()({\n    selectors: {\n      discounted: state =&gt; state * 0.9,\n    },\n  }),\n  flavor: createAdapter&lt;Flavor&gt;()({\n    setToChocolateChip: () =&gt; &#39;Chocolate Chip&#39;,\n    setToOatmealRaisin: () =&gt; &#39;Oatmeal Raisin&#39;,\n  }),\n})();\n\ninterface CookiesState {\n  favorite: CookieState;\n  leastFavorite: CookieState;\n}\nconst initialCookiesState: CookiesState = {\n  favorite: {\n    price: 200,\n    flavor: &#39;Chocolate Chip&#39;,\n  },\n  leastFavorite: {\n    price: 190,\n    flavor: &#39;Oatmeal Raisin&#39;,\n  },\n};\n\nconst cookiesAdapter = joinAdapters&lt;CookiesState&gt;()({\n  favorite: cookieAdapter,\n  leastFavorite: cookieAdapter,\n})({\n  totalPrice: s =&gt; s.favorite.price + s.leastFavorite.price,\n})({\n  totalPriceDiscounted: s =&gt; s.totalPrice * 0.9,\n})();\n\n// Usage\ncookiesAdapter.setFavoriteToOatmealRaisin(initialCookiesState);\ncookiesAdapter.setLeastFavoriteToOatmealRaisin(initialCookiesState);\nconst favoritePriceDiscounted =\n  cookiesAdapter.selectors.favoritePriceDiscounted(initialCookiesState);\nconst totalPrice = cookiesAdapter.selectors.totalPrice(initialCookiesState);\nconst totalPriceDiscounted =\n  cookiesAdapter.selectors.totalPriceDiscounted(initialCookiesState);\n</code></pre>\n<h4 id="example-olympic-sports">Example: Olympic Sports</h4>\n<pre><code class="language-tsx">import { joinAdapters, createAdapter } from &#39;@state-adapt/core&#39;;\n\ninterface SportState {\n  name: string;\n  isOlympic: boolean;\n}\n\nconst sportAdapter = joinAdapters&lt;SportState&gt;()({\n  name: createAdapter&lt;string&gt;()({\n    setToSoccer: () =&gt; &#39;soccer&#39;,\n    setToBasketball: () =&gt; &#39;basketball&#39;,\n  }),\n  isOlympic: createAdapter&lt;boolean&gt;()({\n    setToTrue: () =&gt; true,\n    setToFalse: () =&gt; false,\n  }),\n})({\n  isOlympicAndSoccer: s =&gt; s.isOlympic &amp;&amp; s.name === &#39;soccer&#39;,\n  isOlympicAndBasketball: s =&gt; s.isOlympic &amp;&amp; s.name === &#39;basketball&#39;,\n})({\n  setToOlympicSoccer: {\n    name: () =&gt; &#39;soccer&#39;,\n    isOlympic: () =&gt; true,\n  },\n})();\n</code></pre>\n<h2 id="action"><code>Action</code></h2>\n<p>  <code>Action&lt;T, Type extends string = string&gt;</code> is a type of object that represents an event. It has a <code>type</code> property and a <code>payload</code> property.</p>\n<h2 id="getaction"><code>getAction</code></h2>\n<p>  <code>getAction</code> is a function that takes in an action <code>Type</code> and optionally <code>Payload</code> and creates an <a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/core#action\'})); void(0)"><code>Action</code></a> object.</p>\n<h4 id="example-creating-an-action-with-a-payload">Example: Creating an action with a payload</h4>\n<pre><code class="language-typescript">import { getAction } from &#39;@state-adapt/core&#39;;\n\nconst action = getAction(&#39;ADD&#39;, 1);\n\n// action = { type: &#39;ADD&#39;, payload: 1 }\n</code></pre>\n<h2 id="getid"><code>getId</code></h2>\n<p>  <code>getId</code> returns a unique id.</p>\n'}}return a.\u0275fac=function(n){return new(n||a)},a.\u0275cmp=e.Xpm({type:a,selectors:[["sa-docs-core"]],standalone:!0,features:[e.jDz],decls:2,vars:1,consts:[[3,"html"]],template:function(n,p){1&n&&(e.TgZ(0,"sa-content"),e._UZ(1,"sa-html",0),e.qZA()),2&n&&(e.xp6(1),e.Q6J("html",p.html))},dependencies:[i.S,r.XB],encapsulation:2}),a})()}}]);