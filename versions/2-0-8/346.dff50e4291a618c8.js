"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[346],{1346:(u,n,t)=>{t.r(n),t.d(n,{DocsRxjsComponent:()=>i});var r=t(1917),c=t(2309),e=t(4650);let i=(()=>{class o{constructor(){this.html='<h1 id="state-adaptrxjs">@state-adapt/rxjs</h1>\n<h2 id="peer-dependencies">Peer Dependencies</h2>\n<p><a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/core\'})); void(0)">@state-adapt/core</a></p>\n<p><a href="https://www.npmjs.com/package/rxjs">rxjs</a></p>\n<h2 id="global-configuration">Global Configuration</h2>\n<p><a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/rxjs#configurestateadaptoptions\'})); void(0)"><code>ConfigureStateAdaptOptions</code></a></p>\n<p><a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/rxjs#configurestateadapt\'})); void(0)"><code>configureStateAdapt</code></a></p>\n<h2 id="sources">Sources</h2>\n<p><a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/rxjs#source\'})); void(0)"><code>Source</code></a></p>\n<p><a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/rxjs#tosource\'})); void(0)"><code>toSource</code></a></p>\n<p><a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/rxjs#catcherrorsource\'})); void(0)"><code>catchErrorSource</code></a></p>\n<p><a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/rxjs#torequestsource\'})); void(0)"><code>toRequestSource</code></a></p>\n<p><a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/rxjs#splitsources\'})); void(0)"><code>splitSources</code></a></p>\n<p><a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/rxjs#splitrequestsources\'})); void(0)"><code>splitRequestSources</code></a></p>\n<p><a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/rxjs#getrequestsources\'})); void(0)"><code>getRequestSources</code></a></p>\n<h2 id="stores">Stores</h2>\n<p><a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/rxjs#stateadaptadapt\'})); void(0)"><code>StateAdapt.adapt</code></a></p>\n<p><a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/rxjs#stateadaptwatch\'})); void(0)"><code>StateAdapt.watch</code></a></p>\n<p><a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/rxjs#joinstores\'})); void(0)"><code>joinStores</code></a></p>\n<h2 id="migration-guide">Migration Guide</h2>\n<p><a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/rxjs#200\'})); void(0)">2.0.0</a></p>\n\x3c!-- ## Global Store --\x3e\n\n\n<h2 id="configurestateadaptoptions"><code>ConfigureStateAdaptOptions</code></h2>\n<p>  <code>ConfigureStateAdaptOptions</code> has 4 possible properties:</p>\n<ul class="bx--list--unordered"><li class="bx--list__item"><code>showSelectors?: boolean</code> (default: <code>true</code>) - determines whether to show StateAdapt selectors in Redux DevTools</li><li class="bx--list__item"><code>store</code>: <code>Store</code> - Redux-like store</li><li class="bx--list__item"><code>devtools: any</code> - options for Redux DevTools</li><li class="bx--list__item"><code>preloadedState?: any</code> -  self-explanatory</li></ul><p>  If <code>store</code> is provided, <code>devtools</code> and <code>preloadedState</code> are ignored.</p>\n<h2 id="configurestateadapt"><code>configureStateAdapt</code></h2>\n<blockquote>\n<p>Copilot tip: Copy examples into your file or click to definition to open file with context for better Copilot suggestions.</p>\n</blockquote>\n<p>  <code>configureStateAdapt</code> takes in a <a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/rxjs#configurestateadaptoptions\'})); void(0)"><code>ConfigureStateAdaptOptions</code></a> object and returns a new instance of <a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/rxjs#stateadapt\'})); void(0)"><code>StateAdapt</code></a>.</p>\n<h3 id="example-standalone-with-default-options">Example: Standalone with default options</h3>\n<pre><code class="language-ts">import { actionSanitizer, stateSanitizer } from &#39;@state-adapt/core&#39;;\nimport { configureStateAdapt } from &#39;@state-adapt/rxjs&#39;;\n\nexport const stateAdapt = configureStateAdapt();\n\nexport const { adapt, watch } = stateAdapt;\n</code></pre>\n<h3 id="example-standalone">Example: Standalone</h3>\n<pre><code class="language-ts">import { actionSanitizer, stateSanitizer } from &#39;@state-adapt/core&#39;;\nimport { configureStateAdapt } from &#39;@state-adapt/rxjs&#39;;\n\nexport const stateAdapt = configureStateAdapt({\n  devtools: (window as any)?.__REDUX_DEVTOOLS_EXTENSION__?.({\n    actionSanitizer,\n    stateSanitizer,\n  }),\n  showSelectors: false,\n});\n\nexport const { adapt, watch } = stateAdapt;\n</code></pre>\n<h3 id="example-with-another-store">Example: With another store</h3>\n<pre><code class="language-ts">import { configureStore } from &#39;@reduxjs/toolkit&#39;; // or any other Redux-like store\nimport { configureStateAdapt } from &#39;@state-adapt/rxjs&#39;;\nimport { reducer } from &#39;./reducer&#39;;\n\nconst store = configureStore({ reducer });\n\nexport const stateAdapt = configureStateAdapt({ store });\n\nexport const { adapt, watch } = stateAdapt;\n</code></pre>\n\x3c!-- ## Sources --\x3e\n\n\n<h2 id="source"><code>Source</code></h2>\n<p>  <code>Source</code> extends RxJS&#39; <a href="https://rxjs.dev/guide/subject">Subject</a> with an extra <code>type: string</code> property, and is used to create a stream of <a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/core#action\'})); void(0)"><code>Action</code></a> objects.\n  When creating a source, you must provide a <code>type</code> argument, which will be the <code>type</code> property of the <a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/core#action\'})); void(0)"><code>Action</code></a> objects that will be emitted, and which will\n  appear as the action type in Redux DevTools:</p>\n<p>  <img src="https://state-adapt.github.io/assets/devtools-add$.png" alt="Action Type in Redux Devtools" /></p>\n<h4 id="example-creating-a-source">Example: Creating a source</h4>\n<pre><code class="language-typescript">import { Source } from &#39;@state-adapt/rxjs&#39;;\n\nconst add$ = new Source&lt;number&gt;(&#39;add$&#39;);\n\nadd$.subscribe(action =&gt; console.log(action));\nadd$.next(1);\n// { type: &#39;add$&#39;, payload: 1 }\n</code></pre>\n<h2 id="tosource"><code>toSource</code></h2>\n<p>  <code>toSource</code> is a custom RxJS <a href="https://rxjs.dev/guide/operators">operator</a> that converts an RxJS <a href="https://rxjs.dev/guide/observable">Observable</a>\n  of values of type <code>Payload</code> (inferred) into an observable of values of type <a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/core#action\'})); void(0)"><code>Action</code></a>&lt;<code>Payload</code>, <code>Type</code>&gt;.\n  It takes one argument, <code>type</code>, which is the <code>type</code> property of the <a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/core#action\'})); void(0)"><code>Action</code></a> objects that will be emitted, and which will\n  appear as the action type in Redux DevTools:</p>\n<p>  <img src="https://state-adapt.github.io/assets/devtools-timer$.png" alt="Action Type in Redux Devtools" /></p>\n<h4 id="example-converting-an-observable-into-a-source">Example: Converting an observable into a source</h4>\n<pre><code class="language-typescript">import { timer } from &#39;rxjs&#39;;\nimport { toSource } from &#39;@state-adapt/rxjs&#39;;\n\nconst timer$ = timer(1000).pipe(toSource(&#39;timer$&#39;));\n\ntimer$.subscribe(console.log);\n// { type: &#39;timer$&#39;, payload: 0 }\n</code></pre>\n<h2 id="catcherrorsource"><code>catchErrorSource</code></h2>\n<p>  <code>catchErrorSource</code> is a custom RxJS <a href="https://rxjs.dev/guide/operators">operator</a> that converts an RxJS <a href="https://rxjs.dev/guide/observable">Observable</a>\n  of any values into a source of errors, using RxJS&#39; <a href="https://rxjs.dev/api/operators/catchError">catchError</a> operator.\n  It takes one argument, <code>TypePrefix</code>, and prefixes it to create an object of type <a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/core#action\'})); void(0)"><code>Action</code></a>&lt;any, `${<code>TypePrefix</code>}.error$`&gt;.</p>\n<h4 id="example-catching-errors-from-a-source">Example: Catching errors from a source</h4>\n<pre><code class="language-typescript">import { timer, map } from &#39;rxjs&#39;;\nimport { toSource } from &#39;@state-adapt/rxjs&#39;;\n\nconst timer$ = timer(1000).pipe(\n  map(n =&gt; n.fakeNumberMethod()),\n  toSource(&#39;timer$&#39;),\n  catchErrorSource(&#39;timer&#39;),\n);\n\ntimer$.subscribe(console.log);\n// { type: &#39;timer.error$&#39;, payload: &#39;Error: n.fakeNumberMethod is not a function&#39; }\n</code></pre>\n<h2 id="torequestsource"><code>toRequestSource</code></h2>\n<p>  <code>toRequestSource</code> combines the functionality of <a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/rxjs#tosource\'})); void(0)"><code>toSource</code></a> and <a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/rxjs#catcherrorsource\'})); void(0)"><code>catchErrorSource</code></a> into a single <a href="https://rxjs.dev/guide/operators">operator</a>.</p>\n<p>  <code>toRequestSource</code> converts an RxJS <a href="https://rxjs.dev/guide/observable">Observable</a>\n  of values of type <code>Payload</code> (inferred) into an observable of values of type <a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/core#action\'})); void(0)"><code>Action</code></a>&lt;<code>Payload</code>, `${<code>TypePrefix</code>.success$}`&gt; | <a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/core#action\'})); void(0)"><code>Action</code></a>&lt;any, `${<code>TypePrefix</code>}.error$`&gt;.\n  It takes one argument, <code>typePrefix</code>, which is the prefix of the <code>type</code> property of the <a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/core#action\'})); void(0)"><code>Action</code></a> objects that will be emitted.</p>\n<p>  For the actions emitted without an error, the <code>type</code> property will be `${<code>TypePrefix</code>}.success$}` and the <code>payload</code> property will be the value emitted by the source observable.</p>\n<p>  For the actions emitted with an error, the <code>type</code> property will be `${<code>TypePrefix</code>}.error$}` and the <code>payload</code> property will be the error object.</p>\n<h4 id="example-converting-an-observable-into-a-request-source">Example: Converting an observable into a request source</h4>\n<pre><code class="language-typescript">import { interval } from &#39;rxjs&#39;;\nimport { toRequestSource } from &#39;@state-adapt/rxjs&#39;;\n\nconst interval$ = interval(1000).pipe(\n  map(n =&gt; n &lt; 2 ? n : n.fakeNumberMethod()),\n  toRequestSource(&#39;interval&#39;),\n);\n\ninterval$.subscribe(console.log);\n// { type: &#39;interval.success$&#39;, payload: 0 }\n// { type: &#39;interval.success$&#39;, payload: 1 }\n// { type: &#39;interval.error$&#39;, payload: &#39;Error: n.fakeNumberMethod is not a function&#39; }\n</code></pre>\n<h2 id="splitsources"><code>splitSources</code></h2>\n<p>  <code>splitSources</code> is a function that takes in a <a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/rxjs#source\'})); void(0)"><code>Source</code></a> that emits many kinds of actions and splits it into multiple sources.\n  It takes two arguments:</p>\n<ul class="bx--list--unordered"><li class="bx--list__item"><code>source$</code>: <a href="https://rxjs.dev/guide/observable">Observable</a>&lt;<code>SharedAction</code>&gt;</li><li class="bx--list__item"><code>partitions</code>: <code>PartitionKeys</code> extends { [index: string]: <code>SharedType</code> } \u2014 An object with keys that will become the new source names, and values that will filter against the <code>type</code> property of the actions from the <code>source$</code> observable.</li></ul><p>  It returns an object with keys from the <code>partitions</code> argument and values of type <a href="https://rxjs.dev/guide/observable">Observable</a>&lt;<a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/core#action\'})); void(0)"><code>Action</code></a>&lt;<code>Payload</code>, <code>Type</code>&gt;&gt; where <code>Payload</code> and <code>Type</code> are inferred from\n  the filtered <code>SharedAction</code> type.</p>\n<h4 id="example-splitting-a-source-into-multiple-sources">Example: Splitting a source into multiple sources</h4>\n<pre><code class="language-typescript">import { getAction } from &#39;@state-adapt/core&#39;;\nimport { splitSources } from &#39;@state-adapt/rxjs&#39;;\nimport { interval, map } from &#39;rxjs&#39;;\n\nconst evenAndOdd$ = interval(1000).pipe(map(n =&gt; {\n  const type = n % 2 === 0 ? &#39;even$&#39; : &#39;odd$&#39;;\n  return getAction(type, n);\n}));\n\neventAndOdd$.subscribe(console.log);\n// { type: &#39;even$&#39;, payload: 0 }\n// { type: &#39;odd$&#39;, payload: 1 }\n// { type: &#39;even$&#39;, payload: 2 }\n// { type: &#39;odd$&#39;, payload: 3 }\n\nconst { even$, odd$ } = splitSources(evenAndOdd$, {\n  even$: &#39;even$&#39;,\n  odd$: &#39;odd$&#39;,\n});\n\neven$.subscribe(console.log);\n// { type: &#39;even$&#39;, payload: 0 }\n// { type: &#39;even$&#39;, payload: 2 }\n\n odd$.subscribe(console.log);\n// { type: &#39;odd$&#39;, payload: 1 }\n// { type: &#39;odd$&#39;, payload: 3 }\n</code></pre>\n<h4 id="example-splitting-an-http-source-into-success-and-error-sources">Example: Splitting an HTTP source into success$ and error$ sources</h4>\n<pre><code class="language-typescript">import { getAction } from &#39;@state-adapt/core&#39;;\nimport { toSource, splitSources } from &#39;@state-adapt/rxjs&#39;;\nimport { ajax } from &#39;rxjs/ajax&#39;;\n\nconst http$ = ajax(&#39;https://jsonplaceholder.typicode.com/todos/1&#39;).pipe(\n  toSource(&#39;success$&#39;),\n  catchError(error =&gt; of(getAction(&#39;error$&#39;, error))),\n);\n\nconst { success$, error$ } = splitSources(http$, {\n  success$: &#39;success$&#39;,\n  error$: &#39;error$&#39;,\n});\n\nsuccess$.subscribe(console.log);\n// { type: &#39;success$&#39;, payload: { ... } }\n\nerror$.subscribe(console.log);\n// { type: &#39;error$&#39;, payload: { ... } }\n</code></pre>\n<h2 id="splitrequestsources"><code>splitRequestSources</code></h2>\n<p>  <code>splitRequestSources</code> is a function that takes in the type of <a href="https://rxjs.dev/guide/observable">Observable</a>\n   returned by <a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/rxjs#torequestsource\'})); void(0)"><code>toRequestSource</code></a>, and\n  a prefix <code>TypePrefix</code> to look for in the <a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/core#action\'})); void(0)"><code>Action</code></a> type, and returns an\n  object with two <a href="https://rxjs-dev.firebaseapp.com/guide/observable">Observables</a> of <a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/core#action\'})); void(0)"><code>Action</code></a> objects:  <code>success$</code>, and <code>error$</code>.</p>\n<h4 id="example-splitting-an-observable-of-request-actions-into-success-and-error-sources">Example: Splitting an observable of request actions into success$ and error$ sources</h4>\n<pre><code class="language-typescript">import { interval } from &#39;rxjs&#39;;\nimport { splitRequestSources } from &#39;@state-adapt/rxjs&#39;;\n\nconst interval$ = interval(1000).pipe(\n  map(n =&gt; n &lt; 2 ? n : n.fakeNumberMethod()),\n  toRequestSource(&#39;interval&#39;),\n);\n\nconst { success$, error$ } = splitRequestSources(&#39;interval&#39;, interval$);\n\nsuccess$.subscribe(console.log);\n// { type: &#39;interval.success$&#39;, payload: 0 }\n// { type: &#39;interval.success$&#39;, payload: 1 }\n\nerror$.subscribe(console.log);\n// { type: &#39;interval.error$&#39;, payload: &#39;Error: n.fakeNumberMethod is not a function&#39; }\n</code></pre>\n<h2 id="getrequestsources"><code>getRequestSources</code></h2>\n<p>  <code>getRequestSources</code> is a function that combines the functionality of <a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/rxjs#torequestsource\'})); void(0)"><code>toRequestSource</code></a> and <a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/rxjs#splitrequestsources\'})); void(0)"><code>splitRequestSources</code></a>.</p>\n<p>  <code>getRequestSources</code> takes in an <a href="https://rxjs.dev/guide/observable">Observable</a> and an <a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/core#action\'})); void(0)"><code>Action</code></a> type prefix\n  <code>TypePrefix</code> and splits the observable into two sources\n  that become available as properties on the returned object as <code>success$</code> and <code>error$</code>.</p>\n<h4 id="example-converting-an-observable-into-success-and-error-sources">Example: Converting an observable into success$ and error$ sources</h4>\n<pre><code class="language-typescript">import { interval } from &#39;rxjs&#39;;\nimport { getRequestSources } from &#39;@state-adapt/rxjs&#39;;\n\nconst interval$ = interval(1000).pipe(map(n =&gt; n &lt; 2 ? n : n.fakeNumberMethod()));\n\nconst { success$, error$ } = getRequestSources(&#39;interval&#39;, interval$);\n\nsuccess$.subscribe(console.log);\n// { type: &#39;interval.success$&#39;, payload: 0 }\n// { type: &#39;interval.success$&#39;, payload: 1 }\n\nerror$.subscribe(console.log);\n// { type: &#39;interval.error$&#39;, payload: &#39;Error: n.fakeNumberMethod is not a function&#39; }\n</code></pre>\n<h4 id="example-conveniently-splitting-an-http-source-into-success-and-error-sources">Example: Conveniently splitting an HTTP source into success$ and error$ sources</h4>\n<pre><code class="language-typescript">import { getAction } from &#39;@state-adapt/core&#39;;\nimport { toSource, getRequestSources } from &#39;@state-adapt/rxjs&#39;;\nimport { ajax } from &#39;rxjs/ajax&#39;;\n\nconst http$ = ajax(&#39;https://jsonplaceholder.typicode.com/todos/1&#39;);\n\nconst httpRequest = getRequestSources(&#39;http&#39;, http$);\n\nhttpRequest.success$.subscribe(console.log);\n// { type: &#39;success$&#39;, payload: { ... } }\n\nhttpRequest.error$.subscribe(console.log);\n// { type: &#39;error$&#39;, payload: { ... } }\n</code></pre>\n\x3c!-- ## Stores 1.2.0  --\x3e\n\n\n<h2 id="stateadaptadapt"><code>StateAdapt.adapt</code></h2>\n<blockquote>\n<p>Copilot tip: Copy examples into your file or click to definition to open file with context for better Copilot suggestions.</p>\n</blockquote>\n<p>  <code>adapt</code> creates a store that will manage state while it has subscribers.</p>\n<h3 id="example-initialstate-only">Example: initialState only</h3>\n<p>  <code>adapt(initialState)</code></p>\n<p>  The simplest way to use <code>adapt</code> is to only pass it an initial state. <code>adapt</code> returns a store object that is ready to start managing state once it has subscribers.\n  The store object comes with <code>set</code> and <code>reset</code> methods for updating state, and a <code>state$</code> observable of the store&#39;s state.</p>\n<pre><code class="language-typescript">const name = adapt(&#39;John&#39;);\n\nname.state$.subscribe(console.log); // logs &#39;John&#39;\n\nname.set(&#39;Johnsh&#39;); // logs &#39;Johnsh&#39;\nname.reset(); // logs &#39;John&#39;\n</code></pre>\n<p>  Usually you won&#39;t manually subscribe to state like this, but you can if you want the store to immediately start managing state\n  and never clean it up.</p>\n<h3 id="example-using-an-adapter">Example: Using an adapter</h3>\n<p>  <code>adapt(initialState, adapter)</code></p>\n<p>  You can also pass in a state <a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/core#adapter\'})); void(0)"><code>Adapter</code></a> object to customize the state change functions and selectors.</p>\n<pre><code class="language-typescript">const name = adapt(&#39;John&#39;, {\n  concat: (state, payload: string) =&gt; state + payload,\n  selectors: {\n    length: state =&gt; state.length,\n  },\n});\n\nname.state$.subscribe(console.log); // Logs &#39;John&#39;\nname.length$.subscribe(console.log); // Logs 4\n\nname.concat(&#39;sh&#39;); // logs &#39;Johnsh&#39; and 6\nname.reset(); // logs &#39;John&#39; and 4\n</code></pre>\n<h3 id="example-using-adaptoptions">Example: Using <a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/rxjs#adaptoptions\'})); void(0)"><code>AdaptOptions</code></a></h3>\n<p>  <code>adapt(initialState, { adapter, sources, path })</code></p>\n<p>  You can also define an adapter, sources, and/or a state path as part of an <a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/rxjs#adaptoptions\'})); void(0)"><code>AdaptOptions</code></a> object.</p>\n<p>  Sources allow the store to declaratively react to external events rather than being commanded\n  by imperative callback functions.</p>\n<pre><code class="language-typescript">const tick$ = interval(1000).pipe(toSource(&#39;tick$&#39;));\n\nconst clock = adapt(0, {\n  adapter: {\n    increment: state =&gt; state + 1,\n  },\n  sources: tick$, // or [tick$], or { set: tick$ }, or { set: [tick$] }\n  path: &#39;clock&#39;,\n});\n\nclock.state$.subscribe(console.log); // Logs 0, 1, 2, 3, etc.\n</code></pre>\n<p>  There are 4 possible ways sources can be defined:</p>\n<p>  1. A source can be a single <a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/rxjs#source\'})); void(0)"><code>Source</code></a> or <a href="https://rxjs.dev/guide/observable">Observable</a>&lt;<a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/core#action\'})); void(0)"><code>Action</code></a>&lt;<code>State</code>&gt;&gt;. When the source emits, it triggers the store&#39;s <code>set</code> method\n  with the payload.</p>\n<h4 id="example-single-source">Example: Single source</h4>\n<pre><code class="language-typescript">const nameChange$ = new Source&lt;string&gt;(&#39;nameChange$&#39;);\n\nconst name = adapt(&#39;John&#39;, {\n  sources: nameChange$,\n  path: &#39;name&#39;,\n});\n\nname.state$.subscribe(console.log); // Logs &#39;John&#39;\n\nnameChange$.next(&#39;Johnsh&#39;); // logs &#39;Johnsh&#39;\n</code></pre>\n<p>  2. A source can be an array of <a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/rxjs#source\'})); void(0)"><code>Source</code></a> or <a href="https://rxjs.dev/guide/observable">Observable</a>&lt;<a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/core#action\'})); void(0)"><code>Action</code></a>&lt;<code>State</code>&gt;&gt;. When any of the sources emit, it triggers the store&#39;s <code>set</code>\n   method with the payload.</p>\n<h4 id="example-array-of-sources">Example: Array of sources</h4>\n<pre><code class="language-typescript">const nameChange$ = new Source&lt;string&gt;(&#39;nameChange$&#39;);\nconst nameChange2$ = new Source&lt;string&gt;(&#39;nameChange2$&#39;);\n\nconst name = adapt(&#39;John&#39;, {\n  sources: [nameChange$, nameChange2$],\n  path: &#39;name&#39;,\n});\n\nname.state$.subscribe(console.log); // Logs &#39;John&#39;\n\nnameChange$.next(&#39;Johnsh&#39;); // logs &#39;Johnsh&#39;\nnameChange2$.next(&#39;Johnsh2&#39;); // logs &#39;Johnsh2&#39;\n</code></pre>\n<p>  3. A source can be an object with keys that match the names of the <a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/core#adapter\'})); void(0)"><code>Adapter</code></a> state change functions, with a corresponding source or array of\n  sources that trigger the store&#39;s reaction with the payload.</p>\n<h4 id="example-object-of-sources">Example: Object of sources</h4>\n<pre><code class="language-typescript">const nameChange$ = new Source&lt;string&gt;(&#39;nameChange$&#39;);\nconst nameReset$ = new Source&lt;void&gt;(&#39;nameReset$&#39;);\n\nconst name = adapt(&#39;John&#39;, {\n  sources: {\n    set: nameChange$,\n    reset: nameReset$,\n  },\n  path: &#39;name&#39;,\n});\n\nname.state$.subscribe(console.log); // Logs &#39;John&#39;\n\nnameChange$.next(&#39;Johnsh&#39;); // logs &#39;Johnsh&#39;\nnameReset$.next(); // logs &#39;John&#39;\n</code></pre>\n<p>  4. A source can be a function that takes in a detached store (result of calling <a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/rxjs#stateadaptwatch\'})); void(0)"><code>StateAdapt.watch</code></a>) and returns any of the above\n  types of sources.</p>\n<h4 id="example-function-that-returns-a-source">Example: Function that returns a source</h4>\n<pre><code class="language-typescript">const name = adapt(&#39;John&#39;, {\n  sources: store =&gt; store.state$.pipe(\n    delay(1000),\n    map(name =&gt; `${name}sh`),\n    toSource(&#39;recursive nameChange$&#39;),\n  ),\n  path: &#39;name&#39;,\n});\n\nname.state$.subscribe(console.log); // Logs &#39;John&#39;\n// logs &#39;Johnsh&#39; after 1 second, then &#39;Johnshsh&#39; after 2 seconds, etc.\n</code></pre>\n<p>  Defining a path alongside sources is recommended to enable debugging with Redux DevTools. It&#39;s easy to trace\n  singular state changes caused by user events, but it&#39;s much harder to trace state changes caused by RxJS streams.</p>\n<p>  The path string specifies the location in the global store you will find the state for the store being created\n  (while the store has subscribers). StateAdapt splits this string at periods <code>&#39;.&#39;</code> to create an object path within\n  the global store. Here are some example paths and the resulting global state objects:</p>\n<h4 id="example-paths-and-global-state">Example: Paths and global state</h4>\n<pre><code class="language-typescript">const store = adapt(0, { path: &#39;number&#39; });\nstore.state$.subscribe();\n// global state: { number: 0 }\n</code></pre>\n<pre><code class="language-typescript">const store = adapt(0, { path: &#39;featureA.number&#39; });\nstore.state$.subscribe();\n// global state: { featureA: { number: 0 } }\n</code></pre>\n<pre><code class="language-typescript">const store = adapt(0, { path: &#39;featureA.featureB.number&#39; });\nstore.state$.subscribe();\n// global state: { featureA: { featureB: { number: 0 } } }\n</code></pre>\n<p>  Each store completely owns its own state. If more than one store tries to use the same path, StateAdapt will throw this error:</p>\n<p>  <code>Path &#39;${path}&#39; collides with &#39;${existingPath}&#39;, which has already been initialized as a state path.</code></p>\n<p>  This applies both to paths that are identical as well as paths that are subtrings of each other. For example, if <code>&#39;featureA&#39;</code>\n  is already being used by a store and then another store tried to initialize at <code>&#39;featureA.number&#39;</code>, that error would be thrown.</p>\n<p>  To help avoid this error, StateAdapt provides a <a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/core#getid\'})); void(0)"><code>getId</code></a> function that can be used to generate unique paths:</p>\n<h4 id="example-getid-for-unique-paths">Example: getId for unique paths</h4>\n<pre><code class="language-typescript">import { getId } from &#39;@state-adapt/core&#39;;\n\nconst store1 = adapt(0, { path: &#39;number&#39; + getId() });\nstore1.state$.subscribe();\nconst store2 = adapt(0, { path: &#39;number&#39; + getId() });\nstore2.state$.subscribe();\n// global state includes both: { number0: 0, number1: 0 }\n</code></pre>\n<h3 id="remember">Remember!</h3>\n<p>  The store needs to have subscribers in order to start managing state.</p>\n<h2 id="stateadaptwatch"><code>StateAdapt.watch</code></h2>\n<blockquote>\n<p>Copilot tip: Copy examples into your file or click to definition to open file with context for better Copilot suggestions.</p>\n</blockquote>\n<p>  <code>watch</code> returns a detached store (doesn&#39;t chain off of sources). This allows you to watch state without affecting anything.\n  It takes 2 arguments: The path of the state you are interested in, and the adapter containing the selectors you want to use.</p>\n<pre><code class="language-tsx">watch(path, adapter)\n</code></pre>\n<p>  path \u2014 Object path in Redux Devtools</p>\n<p>  adapter \u2014 Object with state change functions and selectors</p>\n<h3 id="usage">Usage</h3>\n<p>  <code>watch</code> enables accessing state without subscribing to sources. For example, if your adapter manages the loading state\n  for an HTTP request and you need to know if the request is loading before the user is interested in the data,\n  <code>watch</code> can give you access to it without triggering the request.</p>\n<h4 id="example-accessing-loading-state">Example: Accessing loading state</h4>\n<pre><code class="language-tsx">watch(&#39;data&#39;, httpAdapter).loading$.subscribe(console.log);\n</code></pre>\n<h2 id="joinstores"><code>joinStores</code></h2>\n<p>  <code>joinStores</code> is a function that takes in a <code>StoreEntries extends { [index: string]: StoreLike }</code> object and returns a <code>StoreBuilder</code> function.\n  The <code>StoreBuilder</code> function can be called again and again with more selector definitions, and finally with no arguments to create a store.</p>\n<p>  <code>joinStores</code> syntax is identical to that of <a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/core#joinadapters\'})); void(0)"><code>joinAdapters</code></a> so that you can easily switch between the two.\n  The difference is that <code>joinStores</code> can only define selectors, while <code>joinAdapters</code> can define both selectors and reactions.</p>\n<h4 id="example-combining-states-from-two-stores">Example: Combining states from two stores</h4>\n<pre><code class="language-typescript">import { joinStores } from &#39;@state-adapt/rxjs&#39;;\nimport { adapt } from &#39;../configure-state-adapt.ts&#39;;\n\nconst store1 = adapt(1);\nconst store2 = adapt(2);\n\nconst joinedStore = joinStores({ store1, store2 })();\n\njoinedStore.state$.subscribe(console.log);\n// { store1: 1, store2: 2 }\n</code></pre>\n<h4 id="example-combining-selectors-from-two-stores">Example: Combining selectors from two stores</h4>\n<pre><code class="language-typescript">import { createAdapter } from &#39;@state-adapt/core&#39;;\nimport { joinStores } from &#39;@state-adapt/rxjs&#39;;\nimport { adapt } from &#39;../configure-state-adapt.ts&#39;;\n\nconst adapter = createAdapter&lt;number&gt;()({\n  selectors: {\n    double: s =&gt; s * 2,\n  }\n});\n\nconst store1 = adapt(1, adapter);\nconst store2 = adapt(2, adapter);\n\nconst joinedStore = joinStores({ store1, store2 })({\n  sum: s =&gt; s.store1Double + s.store2Double,\n})();\n\njoinedStore.sum$.subscribe(console.log);\n// 6\n</code></pre>\n\x3c!-- cache 20 --\x3e\n\n<h3 id="200">2.0.0</h3>\n<p><a href="https://stackblitz.com/edit/vitejs-vite-bca52l?file=src%2FApp.tsx,src%2FtransformCode.ts">Here is a migrator in StackBlitz</a>\nfor automatic migrating. Use Prettier to format the result.</p>\n<p>The 4 overloads of <a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/rxjs#stateadaptadapt\'})); void(0)"><code>StateAdapt.adapt</code></a> have been removed. Here is the new syntax for each overload:</p>\n<h4 id="1-adaptpath-initialstate"><code>1. adapt(path, initialState)</code></h4>\n<pre><code class="language-typescript">// old\nconst count1 = adapt(&#39;count1&#39;, 4);\n\n// new\nconst count1 = adapt(4);\n</code></pre>\n<h4 id="2-adaptpath-initialstate-adapter"><code>2. adapt([path, initialState], adapter)</code></h4>\n<pre><code class="language-typescript">// old\nconst count2_2 = adapt([&#39;count2_2&#39;, 4], {\n  increment: count =&gt; count + 1,\n  selectors: {\n    isEven: count =&gt; count % 2 === 0,\n  },\n});\n\n// new\nconst count2_2 = adapt(4, {\n  increment: count =&gt; count + 1,\n  selectors: {\n    isEven: count =&gt; count % 2 === 0,\n  },\n});\n</code></pre>\n<h4 id="3-adaptpath-initialstate-sources"><code>3. adapt([path, initialState], sources)</code></h4>\n<pre><code class="language-typescript">// old\nconst count3 = adapt(\n  [&#39;count3&#39;, 4],\n  http.get(&#39;/count/&#39;).pipe(toSource(&#39;http data&#39;)),\n);\n\n// new\nconst count3 = adapt(4, {\n  sources: http.get(&#39;/count/&#39;).pipe(toSource(&#39;http data&#39;)),\n});\n</code></pre>\n<h4 id="4-adaptpath-initialstate-adapter-sources"><code>4. adapt([path, initialState, adapter], sources)</code></h4>\n<pre><code class="language-typescript">// old\nconst adapter4 = createAdapter&lt;number&gt;()({\n  increment: count =&gt; count + 1,\n  selectors: {\n    isEven: count =&gt; count % 2 === 0,\n  },\n});\nconst count4 = adapt([&#39;count4&#39;, 4, adapter4], watched =&gt; {\n  return {\n    set: watched.state$.pipe(delay(1000), toSource(&#39;tick$&#39;)),\n  };\n});\n\n// new\nconst count4 = adapt(4, {\n  adapter: {\n    increment: count =&gt; count + 1,\n    selectors: {\n      isEven: count =&gt; count % 2 === 0,\n    },\n  },\n  sources: watched =&gt; {\n    return {\n      set: watched.state$.pipe(delay(1000), toSource(&#39;tick$&#39;)),\n    };\n  },\n  path: &#39;count4&#39;,\n});\n</code></pre>\n<p>See <a href="https://github.com/state-adapt/state-adapt/issues/45">this GitHub issue</a> for the reasons for this change.</p>\n'}}return o.\u0275fac=function(a){return new(a||o)},o.\u0275cmp=e.Xpm({type:o,selectors:[["sa-docs-rxjs"]],standalone:!0,features:[e.jDz],decls:2,vars:1,consts:[[3,"html"]],template:function(a,p){1&a&&(e.TgZ(0,"sa-content"),e._UZ(1,"sa-html",0),e.qZA()),2&a&&(e.xp6(1),e.Q6J("html",p.html))},dependencies:[c.S,r.XB],encapsulation:2}),o})()}}]);