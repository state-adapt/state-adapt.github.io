"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[346],{1346:(l,n,t)=>{t.r(n),t.d(n,{DocsRxjsComponent:()=>i});var r=t(1917),c=t(2309),e=t(4650);let i=(()=>{class o{constructor(){this.html='<h1 id="state-adaptrxjs">@state-adapt/rxjs</h1>\n<h2 id="peer-dependencies">Peer Dependencies</h2>\n<p><a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/core\'})); void(0)">@state-adapt/core</a></p>\n<h2 id="global-configuration">Global Configuration</h2>\n<p><a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/rxjs#configurestateadaptoptions\'})); void(0)"><code>ConfigureStateAdaptOptions</code></a></p>\n<p><a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/rxjs#configurestateadapt\'})); void(0)"><code>configureStateAdapt</code></a></p>\n<h2 id="sources">Sources</h2>\n<p><a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/rxjs#source\'})); void(0)"><code>Source</code></a></p>\n<p><a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/rxjs#tosource\'})); void(0)"><code>toSource</code></a></p>\n<p><a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/rxjs#catcherrorsource\'})); void(0)"><code>catchErrorSource</code></a></p>\n<p><a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/rxjs#torequestsource\'})); void(0)"><code>toRequestSource</code></a></p>\n<p><a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/rxjs#splitsources\'})); void(0)"><code>splitSources</code></a></p>\n<p><a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/rxjs#splitrequestsources\'})); void(0)"><code>splitRequestSources</code></a></p>\n<p><a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/rxjs#getrequestsources\'})); void(0)"><code>getRequestSources</code></a></p>\n<h2 id="stores">Stores</h2>\n<p><a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/rxjs#stateadaptadapt\'})); void(0)"><code>StateAdapt.adapt</code></a></p>\n<p><a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/rxjs#stateadaptwatch\'})); void(0)"><code>StateAdapt.watch</code></a></p>\n<p><a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/rxjs#joinstores\'})); void(0)"><code>joinStores</code></a></p>\n\x3c!-- ## Global Store --\x3e\n\n\n<h2 id="configurestateadaptoptions"><code>ConfigureStateAdaptOptions</code></h2>\n<p>  <code>ConfigureStateAdaptOptions</code> has 4 possible properties:</p>\n<ul class="bx--list--unordered"><li class="bx--list__item"><code>showSelectors?: boolean</code> (default: <code>true</code>) - determines whether to show StateAdapt selectors in Redux DevTools</li><li class="bx--list__item"><code>store</code>: <code>Store</code> - Redux-like store</li><li class="bx--list__item"><code>devtools: any</code> - options for Redux DevTools</li><li class="bx--list__item"><code>preloadedState?: any</code> -  self-explanatory</li></ul><p>  If <code>store</code> is provided, <code>devtools</code> and <code>preloadedState</code> are ignored.</p>\n<h2 id="configurestateadapt"><code>configureStateAdapt</code></h2>\n<blockquote>\n<p>Copilot tip: Copy examples into your file or click to definition to open file with context for better Copilot suggestions.</p>\n</blockquote>\n<p>  <code>configureStateAdapt</code> takes in a <a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/rxjs#configurestateadaptoptions\'})); void(0)"><code>ConfigureStateAdaptOptions</code></a> object and returns a new instance of <a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/rxjs#stateadapt\'})); void(0)"><code>StateAdapt</code></a>.</p>\n<h3 id="example-standalone-with-default-options">Example: Standalone with default options</h3>\n<pre><code class="language-ts">import { actionSanitizer, stateSanitizer } from &#39;@state-adapt/core&#39;;\nimport { configureStateAdapt } from &#39;@state-adapt/rxjs&#39;;\n\nexport const stateAdapt = configureStateAdapt();\n\nexport const { adapt, watch } = stateAdapt;\n</code></pre>\n<h3 id="example-standalone">Example: Standalone</h3>\n<pre><code class="language-ts">import { actionSanitizer, stateSanitizer } from &#39;@state-adapt/core&#39;;\nimport { configureStateAdapt } from &#39;@state-adapt/rxjs&#39;;\n\nexport const stateAdapt = configureStateAdapt({\n  devtools: (window as any)?.__REDUX_DEVTOOLS_EXTENSION__?.({\n    actionSanitizer,\n    stateSanitizer,\n  }),\n  showSelectors: false,\n});\n\nexport const { adapt, watch } = stateAdapt;\n</code></pre>\n<h3 id="example-with-another-store">Example: With another store</h3>\n<pre><code class="language-ts">import { configureStore } from &#39;@reduxjs/toolkit&#39;; // or any other Redux-like store\nimport { configureStateAdapt } from &#39;@state-adapt/rxjs&#39;;\nimport { reducer } from &#39;./reducer&#39;;\n\nconst store = configureStore({ reducer });\n\nexport const stateAdapt = configureStateAdapt({ store });\n\nexport const { adapt, watch } = stateAdapt;\n</code></pre>\n\x3c!-- ## Sources --\x3e\n\n\n<h2 id="source"><code>Source</code></h2>\n<p>  <code>Source</code> extends RxJS&#39; <a href="https://rxjs.dev/guide/subject">Subject</a> with an extra <code>type: string</code> property, and is used to create a stream of <a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/core#action\'})); void(0)"><code>Action</code></a> objects.\n  When creating a source, you must provide a <code>type</code> argument, which will be the <code>type</code> property of the <a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/core#action\'})); void(0)"><code>Action</code></a> objects that will be emitted, and which will\n  appear as the action type in Redux DevTools:</p>\n<p>  <img src="https://state-adapt.github.io/assets/devtools-add$.png" alt="Action Type in Redux Devtools" /></p>\n<h4 id="example-creating-a-source">Example: Creating a source</h4>\n<pre><code class="language-typescript">import { Source } from &#39;@state-adapt/rxjs&#39;;\n\nconst add$ = new Source&lt;number&gt;(&#39;add$&#39;);\n\nadd$.subscribe(action =&gt; console.log(action));\nadd$.next(1);\n// { type: &#39;add$&#39;, payload: 1 }\n</code></pre>\n<h2 id="tosource"><code>toSource</code></h2>\n<p>  <code>toSource</code> is a custom RxJS <a href="https://rxjs.dev/guide/operators">operator</a> that converts an RxJS <a href="https://rxjs.dev/guide/observable">Observable</a>\n  of values of type <code>Payload</code> (inferred) into an observable of values of type <a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/core#action\'})); void(0)"><code>Action</code></a>&lt;<code>Payload</code>, <code>Type</code>&gt;.\n  It takes one argument, <code>type</code>, which is the <code>type</code> property of the <a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/core#action\'})); void(0)"><code>Action</code></a> objects that will be emitted, and which will\n  appear as the action type in Redux DevTools:</p>\n<p>  <img src="https://state-adapt.github.io/assets/devtools-timer$.png" alt="Action Type in Redux Devtools" /></p>\n<h4 id="example-converting-an-observable-into-a-source">Example: Converting an observable into a source</h4>\n<pre><code class="language-typescript">import { timer } from &#39;rxjs&#39;;\nimport { toSource } from &#39;@state-adapt/rxjs&#39;;\n\nconst timer$ = timer(1000).pipe(toSource(&#39;timer$&#39;));\n\ntimer$.subscribe(console.log);\n// { type: &#39;timer$&#39;, payload: 0 }\n</code></pre>\n<h2 id="catcherrorsource"><code>catchErrorSource</code></h2>\n<p>  <code>catchErrorSource</code> is a custom RxJS <a href="https://rxjs.dev/guide/operators">operator</a> that converts an RxJS <a href="https://rxjs.dev/guide/observable">Observable</a>\n  of any values into a source of errors, using RxJS&#39; <a href="https://rxjs.dev/api/operators/catchError">catchError</a> operator.\n  It takes one argument, <code>TypePrefix</code>, and prefixes it to create an object of type <a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/core#action\'})); void(0)"><code>Action</code></a>&lt;any, `${<code>TypePrefix</code>}.error$`&gt;.</p>\n<h4 id="example-catching-errors-from-a-source">Example: Catching errors from a source</h4>\n<pre><code class="language-typescript">import { timer, map } from &#39;rxjs&#39;;\nimport { toSource } from &#39;@state-adapt/rxjs&#39;;\n\nconst timer$ = timer(1000).pipe(\n  map(n =&gt; n.fakeNumberMethod()),\n  toSource(&#39;timer$&#39;),\n  catchErrorSource(&#39;timer&#39;),\n);\n\ntimer$.subscribe(console.log);\n// { type: &#39;timer.error$&#39;, payload: &#39;Error: n.fakeNumberMethod is not a function&#39; }\n</code></pre>\n<h2 id="torequestsource"><code>toRequestSource</code></h2>\n<p>  <code>toRequestSource</code> combines the functionality of <a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/rxjs#tosource\'})); void(0)"><code>toSource</code></a> and <a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/rxjs#catcherrorsource\'})); void(0)"><code>catchErrorSource</code></a> into a single <a href="https://rxjs.dev/guide/operators">operator</a>.</p>\n<p>  <code>toRequestSource</code> converts an RxJS <a href="https://rxjs.dev/guide/observable">Observable</a>\n  of values of type <code>Payload</code> (inferred) into an observable of values of type <a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/core#action\'})); void(0)"><code>Action</code></a>&lt;<code>Payload</code>, `${<code>TypePrefix</code>.success$}`&gt; | <a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/core#action\'})); void(0)"><code>Action</code></a>&lt;any, `${<code>TypePrefix</code>}.error$`&gt;.\n  It takes one argument, <code>typePrefix</code>, which is the prefix of the <code>type</code> property of the <a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/core#action\'})); void(0)"><code>Action</code></a> objects that will be emitted.</p>\n<p>  For the actions emitted without an error, the <code>type</code> property will be `${<code>TypePrefix</code>}.success$}` and the <code>payload</code> property will be the value emitted by the source observable.</p>\n<p>  For the actions emitted with an error, the <code>type</code> property will be `${<code>TypePrefix</code>}.error$}` and the <code>payload</code> property will be the error object.</p>\n<h4 id="example-converting-an-observable-into-a-request-source">Example: Converting an observable into a request source</h4>\n<pre><code class="language-typescript">import { interval } from &#39;rxjs&#39;;\nimport { toRequestSource } from &#39;@state-adapt/rxjs&#39;;\n\nconst interval$ = interval(1000).pipe(\n  map(n =&gt; n &lt; 2 ? n : n.fakeNumberMethod()),\n  toRequestSource(&#39;interval&#39;),\n);\n\ninterval$.subscribe(console.log);\n// { type: &#39;interval.success$&#39;, payload: 0 }\n// { type: &#39;interval.success$&#39;, payload: 1 }\n// { type: &#39;interval.error$&#39;, payload: &#39;Error: n.fakeNumberMethod is not a function&#39; }\n</code></pre>\n<h2 id="splitsources"><code>splitSources</code></h2>\n<p>  <code>splitSources</code> is a function that takes in a <a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/rxjs#source\'})); void(0)"><code>Source</code></a> that emits many kinds of actions and splits it into multiple sources.\n  It takes two arguments:</p>\n<ul class="bx--list--unordered"><li class="bx--list__item"><code>source$</code>: <a href="https://rxjs.dev/guide/observable">Observable</a>&lt;<code>SharedAction</code>&gt;</li><li class="bx--list__item"><code>partitions</code>: <code>PartitionKeys</code> extends { [index: string]: <code>SharedType</code> } \u2014 An object with keys that will become the new source names, and values that will filter against the <code>type</code> property of the actions from the <code>source$</code> observable.</li></ul><p>  It returns an object with keys from the <code>partitions</code> argument and values of type <a href="https://rxjs.dev/guide/observable">Observable</a>&lt;<a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/core#action\'})); void(0)"><code>Action</code></a>&lt;<code>Payload</code>, <code>Type</code>&gt;&gt; where <code>Payload</code> and <code>Type</code> are inferred from\n  the filtered <code>SharedAction</code> type.</p>\n<h4 id="example-splitting-a-source-into-multiple-sources">Example: Splitting a source into multiple sources</h4>\n<pre><code class="language-typescript">import { getAction } from &#39;@state-adapt/core&#39;;\nimport { splitSources } from &#39;@state-adapt/rxjs&#39;;\nimport { interval, map } from &#39;rxjs&#39;;\n\nconst evenAndOdd$ = interval(1000).pipe(map(n =&gt; {\n  const type = n % 2 === 0 ? &#39;even$&#39; : &#39;odd$&#39;;\n  return getAction(type, n);\n}));\n\neventAndOdd$.subscribe(console.log);\n// { type: &#39;even$&#39;, payload: 0 }\n// { type: &#39;odd$&#39;, payload: 1 }\n// { type: &#39;even$&#39;, payload: 2 }\n// { type: &#39;odd$&#39;, payload: 3 }\n\nconst { even$, odd$ } = splitSources(evenAndOdd$, {\n  even$: &#39;even$&#39;,\n  odd$: &#39;odd$&#39;,\n});\n\neven$.subscribe(console.log);\n// { type: &#39;even$&#39;, payload: 0 }\n// { type: &#39;even$&#39;, payload: 2 }\n\n odd$.subscribe(console.log);\n// { type: &#39;odd$&#39;, payload: 1 }\n// { type: &#39;odd$&#39;, payload: 3 }\n</code></pre>\n<h4 id="example-splitting-an-http-source-into-success-and-error-sources">Example: Splitting an HTTP source into success$ and error$ sources</h4>\n<pre><code class="language-typescript">import { getAction } from &#39;@state-adapt/core&#39;;\nimport { toSource, splitSources } from &#39;@state-adapt/rxjs&#39;;\nimport { ajax } from &#39;rxjs/ajax&#39;;\n\nconst http$ = ajax(&#39;https://jsonplaceholder.typicode.com/todos/1&#39;).pipe(\n  toSource(&#39;success$&#39;),\n  catchError(error =&gt; of(getAction(&#39;error$&#39;, error))),\n);\n\nconst { success$, error$ } = splitSources(http$, {\n  success$: &#39;success$&#39;,\n  error$: &#39;error$&#39;,\n});\n\nsuccess$.subscribe(console.log);\n// { type: &#39;success$&#39;, payload: { ... } }\n\nerror$.subscribe(console.log);\n// { type: &#39;error$&#39;, payload: { ... } }\n</code></pre>\n<h2 id="splitrequestsources"><code>splitRequestSources</code></h2>\n<p>  <code>splitRequestSources</code> is a function that takes in the type of <a href="https://rxjs.dev/guide/observable">Observable</a>\n   returned by <a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/rxjs#torequestsource\'})); void(0)"><code>toRequestSource</code></a>, and\n  a prefix <code>TypePrefix</code> to look for in the <a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/core#action\'})); void(0)"><code>Action</code></a> type, and returns an\n  object with two <a href="https://rxjs-dev.firebaseapp.com/guide/observable">Observables</a> of <a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/core#action\'})); void(0)"><code>Action</code></a> objects:  <code>success$</code>, and <code>error$</code>.</p>\n<h4 id="example-splitting-an-observable-of-request-actions-into-success-and-error-sources">Example: Splitting an observable of request actions into success$ and error$ sources</h4>\n<pre><code class="language-typescript">import { interval } from &#39;rxjs&#39;;\nimport { splitRequestSources } from &#39;@state-adapt/rxjs&#39;;\n\nconst interval$ = interval(1000).pipe(\n  map(n =&gt; n &lt; 2 ? n : n.fakeNumberMethod()),\n  toRequestSource(&#39;interval&#39;),\n);\n\nconst { success$, error$ } = splitRequestSources(&#39;interval&#39;, interval$);\n\nsuccess$.subscribe(console.log);\n// { type: &#39;interval.success$&#39;, payload: 0 }\n// { type: &#39;interval.success$&#39;, payload: 1 }\n\nerror$.subscribe(console.log);\n// { type: &#39;interval.error$&#39;, payload: &#39;Error: n.fakeNumberMethod is not a function&#39; }\n</code></pre>\n<h2 id="getrequestsources"><code>getRequestSources</code></h2>\n<p>  <code>getRequestSources</code> is a function that combines the functionality of <a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/rxjs#torequestsource\'})); void(0)"><code>toRequestSource</code></a> and <a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/rxjs#splitrequestsources\'})); void(0)"><code>splitRequestSources</code></a>.</p>\n<p>  <code>getRequestSources</code> takes in an <a href="https://rxjs.dev/guide/observable">Observable</a> and an <a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/core#action\'})); void(0)"><code>Action</code></a> type prefix\n  <code>TypePrefix</code> and splits the observable into two sources\n  that become available as properties on the returned object as <code>success$</code> and <code>error$</code>.</p>\n<h4 id="example-converting-an-observable-into-success-and-error-sources">Example: Converting an observable into success$ and error$ sources</h4>\n<pre><code class="language-typescript">import { interval } from &#39;rxjs&#39;;\nimport { getRequestSources } from &#39;@state-adapt/rxjs&#39;;\n\nconst interval$ = interval(1000).pipe(map(n =&gt; n &lt; 2 ? n : n.fakeNumberMethod()));\n\nconst { success$, error$ } = getRequestSources(&#39;interval&#39;, interval$);\n\nsuccess$.subscribe(console.log);\n// { type: &#39;interval.success$&#39;, payload: 0 }\n// { type: &#39;interval.success$&#39;, payload: 1 }\n\nerror$.subscribe(console.log);\n// { type: &#39;interval.error$&#39;, payload: &#39;Error: n.fakeNumberMethod is not a function&#39; }\n</code></pre>\n<h4 id="example-conveniently-splitting-an-http-source-into-success-and-error-sources">Example: Conveniently splitting an HTTP source into success$ and error$ sources</h4>\n<pre><code class="language-typescript">import { getAction } from &#39;@state-adapt/core&#39;;\nimport { toSource, getRequestSources } from &#39;@state-adapt/rxjs&#39;;\nimport { ajax } from &#39;rxjs/ajax&#39;;\n\nconst http$ = ajax(&#39;https://jsonplaceholder.typicode.com/todos/1&#39;);\n\nconst httpRequest = getRequestSources(&#39;http&#39;, http$);\n\nhttpRequest.success$.subscribe(console.log);\n// { type: &#39;success$&#39;, payload: { ... } }\n\nhttpRequest.error$.subscribe(console.log);\n// { type: &#39;error$&#39;, payload: { ... } }\n</code></pre>\n\x3c!-- ## Stores 1.2.0  --\x3e\n\n\n<h2 id="stateadaptadapt"><code>StateAdapt.adapt</code></h2>\n<blockquote>\n<p>Copilot tip: Copy examples into your file or click to definition to open file with context for better Copilot suggestions.</p>\n</blockquote>\n<p>  <code>adapt</code> creates a store that will manage state while it has subscribers. There are 4 overloads for <code>adapt</code>:</p>\n<h3 id="overloads">Overloads</h3>\n<pre><code class="language-javascript">adapt(path, initialState)\nadapt([path, initialState], adapter)\nadapt([path, initialState], sources)\nadapt([path, initialState, adapter], sources)\n</code></pre>\n<p>  path: <code>string</code> \u2014 Object path in Redux Devtools</p>\n<p>  initialState: <code>State</code> \u2014 Initial state of the store when it gets initialized with a subscription to its state</p>\n<p>  adapter: <a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/core#adapter\'})); void(0)"><code>Adapter</code></a> \u2014 Object with state change functions and selectors</p>\n<p>  sources:</p>\n<ul class="bx--list--unordered"><li class="bx--list__item"><a href="https://rxjs.dev/guide/observable">Observable</a>&lt;<a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/core#action\'})); void(0)"><code>Action</code></a>&lt;<code>State</code>&gt;&gt; \u2014 Single source for <code>set</code> state change</li><li class="bx--list__item"><a href="https://rxjs.dev/guide/observable">Observable</a>&lt;<a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/core#action\'})); void(0)"><code>Action</code></a>&lt;<code>State</code>&gt;&gt;[] \u2014 Array of sources for <code>set</code> state change</li><li class="bx--list__item"><a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/rxjs#sources\'})); void(0)"><code>Sources</code></a> \u2014 Object specifying sources for state change functions</li></ul><h3 id="overload-1">Overload 1</h3>\n<p>  <code>adapt(path, initialState)</code></p>\n<p>  The path string specifies the location in the global store you will find the state for the store being created\n  (while the store has subscribers). StateAdapt splits this string at periods <code>&#39;.&#39;</code> to create an object path within\n  the global store. Here are some example paths and the resulting global state objects:</p>\n<h4 id="example-paths-and-global-state">Example: Paths and global state</h4>\n<pre><code class="language-typescript">const store = adapt(&#39;number&#39;, 0);\nstore.state$.subscribe();\n// global state: { number: 0 }\n\nconst store = adapt(&#39;featureA.number&#39;, 0);\nstore.state$.subscribe();\n// global state: { featureA: { number: 0 } }\n\nconst store = adapt(&#39;featureA.featureB.number&#39;, 0);\nstore.state$.subscribe();\n// global state: { featureA: { featureB: { number: 0 } } }\n</code></pre>\n<p>  Each store completely owns its own state. If more than one store tries to use the same path, StateAdapt will throw this error:</p>\n<p>  <code>Path &#39;${path}&#39; collides with &#39;${existingPath}&#39;, which has already been initialized as a state path.</code></p>\n<p>  This applies both to paths that are identical as well as paths that are subtrings of each other. For example, if <code>&#39;featureA&#39;</code>\n  is already being used by a store and then another store tried to initialize at <code>&#39;featureA.number&#39;</code>, that error would be thrown.</p>\n<p>  To help avoid this error, StateAdapt provides a <a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/core#getid\'})); void(0)"><code>getId</code></a> function that can be used to generate unique paths:</p>\n<h4 id="example-getid-for-unique-paths">Example: getId for unique paths</h4>\n<pre><code class="language-typescript">import { getId } from &#39;@state-adapt/core&#39;;\n\nconst store1 = adapt(&#39;number&#39; + getId(), 0);\nstore1.state$.subscribe();\nconst store2 = adapt(&#39;number&#39; + getId(), 0);\nstore2.state$.subscribe();\n// global state: { number0: 0, number1: 0 }\n</code></pre>\n<p>  <code>adapt</code> returns a store object that is ready to start managing state once it has subscribers. The store object comes with <code>set</code>\n  and <code>reset</code> methods for updating the state, and a <code>state$</code> observable of the store&#39;s state.</p>\n<h4 id="example-set-reset-and-state">Example: <code>set</code>, <code>reset</code> and <code>state$</code></h4>\n<pre><code class="language-tsx">const name = adapt(&#39;name&#39;, &#39;John&#39;);\nname.state$.subscribe(console.log);\nname.set(&#39;Johnsh&#39;); // logs &#39;Johnsh&#39;\nname.reset(); // logs &#39;John&#39;\n</code></pre>\n<p>  Usually you won&#39;t manually subscribe to state like this, but you can if you want the store to immediately start managing state\n  and never clean it up.</p>\n<h3 id="overload-2">Overload 2</h3>\n<p>  <code>adapt([path, initialState], adapter)</code></p>\n<p>  The adapter is an object such as one created by <a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/core#createadapter\'})); void(0)"><code>createAdapter</code></a>. It contains methods for updating state,\n  called &quot;state changes&quot; or &quot;reactions&quot;, and optionally selectors for reading the state. Every reaction function becomes a method on\n  the store object, and every selector becomes an observable on the store object.</p>\n<h4 id="example-inlined-adapter">Example: Inlined adapter</h4>\n<pre><code class="language-tsx">const name = adapt([&#39;name&#39;, &#39;John&#39;], {\n  concat: (state, payload: string) =&gt; state + payload,\n  selectors: {\n    length: state =&gt; state.length,\n  },\n});\nname.state$.subscribe(console.log);\nname.length$.subscribe(console.log);\nname.concat(&#39;sh&#39;); // logs &#39;Johnsh&#39; and 6\nname.reset(); // logs &#39;John&#39; and 4\n</code></pre>\n<h3 id="overload-3">Overload 3</h3>\n<p>  <code>adapt([path, initialState], sources)</code></p>\n<p>  Sources allow the store to react to external events. There are 4 possible ways sources can be defined:</p>\n<p>  1. A source can be a single <code>Source</code> or <a href="https://rxjs.dev/guide/observable">Observable</a>&lt;<a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/core#action\'})); void(0)"><code>Action</code></a>&lt;<code>State</code>&gt;&gt;. When the source emits, it triggers the store&#39;s <code>set</code> method\n  with the payload.</p>\n<h4 id="example-single-source">Example: Single source</h4>\n<pre><code class="language-tsx">const nameChange$ = new Source&lt;string&gt;(&#39;nameChange$&#39;);\n\nconst name = adapt([&#39;name&#39;, &#39;John&#39;], nameChange$);\n\nname.state$.subscribe(console.log);\nnameChange$.next(&#39;Johnsh&#39;); // logs &#39;Johnsh&#39;\n</code></pre>\n<p>  2. A source can be an array of <code>Source</code> or <a href="https://rxjs.dev/guide/observable">Observable</a>&lt;<a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/core#action\'})); void(0)"><code>Action</code></a>&lt;<code>State</code>&gt;&gt;. When any of the sources emit, it triggers the store&#39;s <code>set</code>\n   method with the payload.</p>\n<h4 id="example-array-of-sources">Example: Array of sources</h4>\n<pre><code class="language-tsx">const nameChange$ = new Source&lt;string&gt;(&#39;nameChange$&#39;);\nconst nameChange2$ = new Source&lt;string&gt;(&#39;nameChange2$&#39;);\n\nconst name = adapt([&#39;name&#39;, &#39;John&#39;], [nameChange$, nameChange2$]);\n\nname.state$.subscribe(console.log);\nnameChange$.next(&#39;Johnsh&#39;); // logs &#39;Johnsh&#39;\nnameChange2$.next(&#39;Johnsh2&#39;); // logs &#39;Johnsh2&#39;\n</code></pre>\n<p>  3. A source can be an object with keys that match the names of the store&#39;s reactions, with a corresponding source or array of\n  sources that trigger the store&#39;s reaction with the payload.</p>\n<h4 id="example-object-of-sources">Example: Object of sources</h4>\n<pre><code class="language-tsx">const nameChange$ = new Source&lt;string&gt;(&#39;nameChange$&#39;);\nconst nameReset$ = new Source&lt;void&gt;(&#39;nameReset$&#39;);\n\nconst name = adapt([&#39;name&#39;, &#39;John&#39;], {\n  set: nameChange$,\n  reset: [nameReset$], // Can be array of sources too\n});\n\nname.state$.subscribe(console.log);\nnameChange$.next(&#39;Johnsh&#39;); // logs &#39;Johnsh&#39;\nnameReset$.next(); // logs &#39;John&#39;\n</code></pre>\n<p>  4. A source can be a function that takes in a detached store (result of calling <code>watch</code>) and returns any of the above\n  types of sources.</p>\n<h4 id="example-function-that-returns-a-source">Example: Function that returns a source</h4>\n<pre><code class="language-tsx">name = adapt([&#39;name&#39;, &#39;John&#39;], store =&gt; store.state$.pipe(\n  delay(1000),\n  map(name =&gt; `${name}sh`),\n  toSource(&#39;recursive nameChange$&#39;),\n));\n\nconst sub = name.state$.subscribe(console.log);\n// logs &#39;Johnsh&#39; after 1 second, then &#39;Johnshsh&#39; after 2 seconds, etc.\n</code></pre>\n<p>  Each selector&#39;s observable chains off of all the sources passed into the store. For example, if one of your sources\n  is an observable of an HTTP request, that request will automatically be triggered as soon as you subscribe to any of\n  the selector observables from the store. If necessary, you can access store selectors that do not chain off of any\n  sources by using the <a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/rxjs#stateadaptwatch\'})); void(0)"><code>StateAdapt.watch</code></a> function.</p>\n<h3 id="overload-4">Overload 4</h3>\n<p>  <code>adapt([path, initialState, adapter], sources)</code></p>\n<p>  The adapter and sources can be combined in the same overload.</p>\n<h4 id="example-adapter-and-sources">Example: Adapter and sources</h4>\n<pre><code class="language-tsx">const nameChange$ = new Source&lt;string&gt;(&#39;nameChange$&#39;);\nconst nameConcat$ = new Source&lt;string&gt;(&#39;nameConcat$&#39;);\n\nconst nameAdapter = createAdapter&lt;string&gt;()({\n  concat: (state, payload: string) =&gt; state + payload,\n});\n\nconst name = adapt([&#39;name&#39;, &#39;John&#39;, nameAdapter], {\n  set: nameChange$,\n  concat: nameConcat$,\n});\n\nname.state$.subscribe(console.log);\nnameChange$.next(&#39;Johnsh&#39;); // logs &#39;Johnsh&#39;\nnameConcat$.next(&#39;sh&#39;); // logs &#39;Johnshsh&#39; // Example suggested by Copilot :)\n</code></pre>\n<h3 id="remember">Remember!</h3>\n<p>  The store needs to have subscribers in order to start managing state.</p>\n<p>  @deprecated Use for debugging only. Prefer the <a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/rxjs#stateadaptadapt\'})); void(0)"><code>StateAdapt.adapt</code></a> sources syntax that exposes a detached store.</p>\n<h2 id="stateadaptwatch"><code>StateAdapt.watch</code></h2>\n<blockquote>\n<p>Copilot tip: Copy examples into your file or click to definition to open file with context for better Copilot suggestions.</p>\n</blockquote>\n<p>  <code>watch</code> returns a detached store (doesn&#39;t chain off of sources). This allows you to watch state without affecting anything.\n  It takes 2 arguments: The path of the state you are interested in, and the adapter containing the selectors you want to use.</p>\n<pre><code class="language-tsx">watch(path, adapter)\n</code></pre>\n<p>  path \u2014 Object path in Redux Devtools</p>\n<p>  adapter \u2014 Object with state change functions and selectors</p>\n<h3 id="usage">Usage</h3>\n<p>  <code>watch</code> is useful in 2 situations primarily: Accessing state without subscribing and accessing state for a source.</p>\n<h3 id="accessing-state-without-subscribing">Accessing state without subscribing</h3>\n<p>  <code>watch</code> enables accessing state without subscribing to sources. For example, if your adapter manages the loading state\n  for an HTTP request and you need to know if the request is loading before the user is interested in the data,\n  <code>watch</code> can give you access to it without triggering the request.</p>\n<h4 id="example-accessing-loading-state">Example: Accessing loading state</h4>\n<pre><code class="language-tsx">watch(&#39;data&#39;, httpAdapter).loading$.subscribe(console.log);\n</code></pre>\n<h3 id="accessing-state-for-a-source">Accessing state for a source</h3>\n<p>  It would be impossible for a source itself to access state from the store without <code>watch</code> because\n  it would require using the store before it had been defined. The solution is to use <code>watch</code>\n  to access the state needed by <code>dataReceived$</code>:</p>\n<h4 id="example-accessing-state-for-a-source">Example: Accessing state for a source</h4>\n<pre><code class="language-tsx">const path = &#39;data&#39;; // Make sure the same path is used in both places\n\nconst dataReceived$ = watch(path, dataAdapter).dataNeeded$.pipe(\n  filter(needed =&gt; needed),\n  switchMap(() =&gt; dataService.fetchData()),\n  toSource(&#39;dataReceived$&#39;),\n);\n\nconst dataStore = adapt([path, initialState, dataAdapter], {\n  receive: dataReceived$,\n});\n</code></pre>\n<h2 id="joinstores"><code>joinStores</code></h2>\n<p>  <code>joinStores</code> is a function that takes in a <code>StoreEntries extends { [index: string]: StoreLike }</code> object and returns a <code>StoreBuilder</code> function.\n  The <code>StoreBuilder</code> function can be called again and again with more selector definitions, and finally with no arguments to create a store.</p>\n<p>  <code>joinStores</code> syntax is identical to that of <a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/core#joinadapters\'})); void(0)"><code>joinAdapters</code></a> so that you can easily switch between the two.\n  The difference is that <code>joinStores</code> can only define selectors, while <code>joinAdapters</code> can define both selectors and reactions.</p>\n<h4 id="example-combining-states-from-two-stores">Example: Combining states from two stores</h4>\n<pre><code class="language-typescript">import { joinStores } from &#39;@state-adapt/rxjs&#39;;\nimport { adapt } from &#39;../configure-state-adapt.ts&#39;;\n\nconst store1 = adapt(&#39;store1&#39;, 1);\nconst store2 = adapt(&#39;store2&#39;, 2);\n\nconst joinedStore = joinStores({ store1, store2 })();\n\njoinedStore.state$.subscribe(console.log);\n// { store1: 1, store2: 2 }\n</code></pre>\n<h4 id="example-combining-selectors-from-two-stores">Example: Combining selectors from two stores</h4>\n<pre><code class="language-typescript">import { createAdapter } from &#39;@state-adapt/core&#39;;\nimport { joinStores } from &#39;@state-adapt/rxjs&#39;;\nimport { adapt } from &#39;../configure-state-adapt.ts&#39;;\n\nconst adapter = createAdapter&lt;number&gt;()({\n  selectors: {\n    double: s =&gt; s * 2,\n  }\n});\n\nconst store1 = adapt([&#39;store1&#39;, 1], adapter);\nconst store2 = adapt([&#39;store2&#39;, 2], adapter);\n\nconst joinedStore = joinStores({ store1, store2 })({\n  sum: s =&gt; s.store1Double + s.store2Double,\n})();\n\njoinedStore.sum$.subscribe(console.log);\n// 6\n \n</code></pre>\n'}}return o.\u0275fac=function(a){return new(a||o)},o.\u0275cmp=e.Xpm({type:o,selectors:[["sa-docs-rxjs"]],standalone:!0,features:[e.jDz],decls:2,vars:1,consts:[[3,"html"]],template:function(a,p){1&a&&(e.TgZ(0,"sa-content"),e._UZ(1,"sa-html",0),e.qZA()),2&a&&(e.xp6(1),e.Q6J("html",p.html))},dependencies:[c.S,r.XB],encapsulation:2}),o})()}}]);