"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[105],{8105:(u,a,e)=>{e.r(a),e.d(a,{DocsReactComponent:()=>i});var r=e(1917),c=e(2309),t=e(4650);let i=(()=>{class o{constructor(){this.html='<h1 id="state-adaptreact">@state-adapt/react</h1>\n<h2 id="peer-dependencies">Peer Dependencies</h2>\n<p><a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/core\'})); void(0)">@state-adapt/core</a></p>\n<p><a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/rxjs\'})); void(0)">@state-adapt/rxjs</a></p>\n<h2 id="index">Index</h2>\n<p><a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/react/docs/react#usestore\'})); void(0)"><code>useStore</code></a></p>\n<p><a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/react/docs/react#useadapt\'})); void(0)"><code>useAdapt</code></a></p>\n\x3c!-- [`useAdapt`](/react/docs/react#useadapt) --\x3e\n\n\n<h2 id="usestore"><code>useStore</code></h2>\n<blockquote>\n<p>Copilot tip: Copy examples into your file or click to definition to open file with context for better Copilot suggestions.</p>\n</blockquote>\n<p>  <code>useStore</code> is a custom hook that takes in a store created outside a component with <a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/rxjs#stateadaptadapt\'})); void(0)"><code>StateAdapt.adapt</code></a>, subscribes to it,\n  and returns a proxy that can be used as if it is an object with derived state itself from selectors.\n  When the store&#39;s state changes, it will trigger the component to re-render, no matter what selectors are being accessed from the proxy.\n  The selectors are evaluated lazily.</p>\n<h4 id="example-basic-usestore-usage">Example: Basic useStore usage</h4>\n<pre><code class="language-tsx">import { adapt } from &#39;../store&#39;; // Import from wherever you configure StateAdapt\nimport { useStore } from &#39;@state-adapt/react&#39;;\n\nconst nameStore = adapt([&#39;name&#39;, &#39;Bob&#39;], {\n  concat: (state, name: string) =&gt; state + name,\n  selectors: {\n    uppercase: state =&gt; state.toUpperCase(),\n  }\n});\n\nexport function MyComponent() {\n  const name = useStore(nameStore);\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;Hello {name.uppercase}&lt;/h1&gt;\n      &lt;button onClick={() =&gt; nameStore.concat(&#39;!&#39;)}&gt;Concat&lt;/button&gt;\n    &lt;/div&gt;\n  );\n}\n</code></pre>\n<h4 id="example-lazy-selector-evaluation">Example: Lazy selector evaluation</h4>\n<pre><code class="language-tsx">import { adapt } from &#39;../store&#39;; // Import from wherever you configure StateAdapt\nimport { useStore } from &#39;@state-adapt/react&#39;;\n\nconst counterStore = adapt([&#39;counter&#39;, 0], {\n  increment: state =&gt; state + 1,\n  decrement: state =&gt; state - 1,\n  selectors: {\n    isEven: state =&gt; state % 2 === 0,\n    isOdd: state =&gt; state % 2 !== 0,\n  }\n});\n\nexport function MyComponent() {\n  const counter = useStore(counterStore);\n\n  // Until the count is greater than 5 and the extra part below renders,\n  // the isEvent and isOdd selectors will not be evaluated\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;Counter: {counter.state}&lt;/h1&gt;\n      &lt;button onClick={() =&gt; counterStore.increment()}&gt;Increment&lt;/button&gt;\n      &lt;button onClick={() =&gt; counterStore.decrement()}&gt;Decrement&lt;/button&gt;\n\n      {counter.state &gt; 5 &amp;&amp; (\n        &lt;h2&gt;Is even: {counter.isEven ? &#39;Yes&#39; : &#39;No&#39;}&lt;/h2&gt;\n        &lt;h2&gt;Is odd: {counter.isOdd ? &#39;Yes&#39; : &#39;No&#39;}&lt;/h2&gt;\n      )}\n    &lt;/div&gt;\n  );\n}\n</code></pre>\n<h2 id="useadapt"><code>useAdapt</code></h2>\n<blockquote>\n<p>Copilot tip: Copy examples into your file or click to definition to open file with context for better Copilot suggestions.</p>\n</blockquote>\n<p>  <code>useAdapt</code> is a hook that wraps <a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/rxjs#stateadaptadapt\'})); void(0)"><code>StateAdapt.adapt</code></a> and <a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/react/docs/react#usestore\'})); void(0)"><code>useStore</code></a>.\n  It creates a store, immediately subscribes to it, and returns a <code>[proxy, store]</code> tuple, where\n  <code>proxy</code> is the return value of <a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/react/docs/react#usestore\'})); void(0)"><code>useStore</code></a> and <code>store</code> is the return value of <a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/rxjs#stateadaptadapt\'})); void(0)"><code>StateAdapt.adapt</code></a>.</p>\n<p>  <code>useAdapt</code> is like an advanced version of <a href="https://beta.reactjs.org/reference/react/useState"><code>useState</code></a>\n  or <a href="https://beta.reactjs.org/reference/react/useReducer"><code>useReducer</code></a>. All of the values you pass into it\n  are only used once, when the store is created. Any further updates to the store need to be done through\n  the store itself (returned by <code>useAdapt</code> in the second position of the tuple) or indirectly through the sources\n  passed into <code>useAdapt</code>.</p>\n<h3 id="overloads">Overloads</h3>\n<pre><code class="language-javascript">useAdapt(path, initialState)\nuseAdapt([path, initialState], adapter)\nuseAdapt([path, initialState], sources)\nuseAdapt([path, initialState, adapter], sources)\n</code></pre>\n<p>  path: <code>string</code> \u2014 Object path in Redux Devtools</p>\n<p>  initialState: <code>State</code> \u2014 Initial state of the store when it gets initialized with a subscription to its state</p>\n<p>  adapter: <code>Adapter</code> \u2014 Object with state change functions and selectors</p>\n<p>  sources:</p>\n<ul class="bx--list--unordered"><li class="bx--list__item"><a href="https://rxjs.dev/guide/observable">Observable</a>&lt;<a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/core#action\'})); void(0)"><code>Action</code></a>&lt;<code>State</code>&gt;&gt; \u2014 Single source for <code>set</code> state change</li><li class="bx--list__item"><a href="https://rxjs.dev/guide/observable">Observable</a>&lt;<a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/core#action\'})); void(0)"><code>Action</code></a>&lt;<code>State</code>&gt;&gt;[] \u2014 Array of sources for <code>set</code> state change</li><li class="bx--list__item"><a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/rxjs#sources\'})); void(0)"><code>Sources</code></a> \u2014 Object specifying sources for state change functions</li></ul><h3 id="overload-1">Overload 1</h3>\n<p>  <code>useAdapt(path, initialState)</code></p>\n<p>  The path string specifies the location in the global store you will find the state for the store being created.\n  StateAdapt splits this string at periods <code>&#39;.&#39;</code> to create an object path within\n  the global store. Here are some example paths and the resulting global state objects:</p>\n<h4 id="example-paths-and-global-state">Example: Paths and global state</h4>\n<pre><code class="language-typescript">const [states, store] = useAdapt(&#39;number&#39;, 0);\n// global state: { number: 0 }\n\nconst [states, store] = useAdapt(&#39;featureA.number&#39;, 0);\n// global state: { featureA: { number: 0 } }\n\nconst [states, store] = useAdapt(&#39;featureA.featureB.number&#39;, 0);\n// global state: { featureA: { featureB: { number: 0 } } }\n</code></pre>\n<p>  Each store completely owns its own state. If more than one store tries to use the same path, StateAdapt will throw this error:</p>\n<p>  <code>Path &#39;${path}&#39; collides with &#39;${existingPath}&#39;, which has already been initialized as a state path.</code></p>\n<p>  This applies both to paths that are identical as well as paths that are subtrings of each other. For example, if <code>&#39;featureA&#39;</code>\n  is already being used by a store and then another store tried to initialize at <code>&#39;featureA.number&#39;</code>, that error would be thrown.</p>\n<p>  To help avoid this error, StateAdapt provides a <a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/core#getid\'})); void(0)"><code>getId</code></a> function that can be used to generate unique paths:</p>\n<h4 id="example-getid-for-unique-paths">Example: getId for unique paths</h4>\n<pre><code class="language-typescript">import { getId } from &#39;@state-adapt/core&#39;;\n\nconst path0 = &#39;number&#39; + getId();\nconst path1 = &#39;number&#39; + getId();\n\nexport const MyComponent = () =&gt; {\n  const [states1, store1] = useAdapt(path0, 0);\n  const [states2, store2] = useAdapt(path1, 0);\n  // global state: { number0: 0, number1: 0 }\n  return &lt;div&gt;{states1.state} {states2.state}&lt;/div&gt;;\n};\n</code></pre>\n<p>  The store object returned in the 2nd place in the tuple comes with <code>set</code>\n  and <code>reset</code> methods for updating the state, and a <code>state$</code> RxJS\n  <a href="https://rxjs.dev/guide/observable"><code>Observable</code></a> of the store&#39;s state.\n  But with <code>useAdapt</code> you will usually access the store&#39;s state through the\n  proxy object returned in the 1st place in the tuple.</p>\n<h4 id="example-set-reset-and-state">Example: <code>set</code>, <code>reset</code> and <code>state$</code></h4>\n<pre><code class="language-tsx">export const MyComponent = () =&gt; {\n  const [name, nameStore] = useAdapt(&#39;name&#39;, &#39;John&#39;);\n\n  // Shows &quot;John&quot; first\n  // Shows &quot;Johnsh&quot; when the &quot;Set&quot; button is clicked\n  // Shows &quot;John&quot; again when the &quot;Reset&quot; button is clicked\n  return (\n    &lt;&gt;\n      &lt;div&gt;{name.state}&lt;/div&gt;\n      &lt;button onClick={() =&gt; nameStore.set(&#39;Johnsh&#39;)}&gt;Set&lt;/button&gt;\n      &lt;button onClick={() =&gt; nameStore.reset()}&gt;Reset&lt;/button&gt;\n    &lt;/&gt;\n  );\n};\n</code></pre>\n<h3 id="overload-2">Overload 2</h3>\n<p>  <code>useAdapt([path, initialState], adapter)</code></p>\n<p>  The adapter is an object such as one created by <a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/core#createadapter\'})); void(0)"><code>createAdapter</code></a>. It contains methods for updating state,\n  called &quot;state changes&quot; or &quot;reactions&quot;, and optionally selectors for reading the state. Every reaction function becomes a method on\n  the store object, and every selector becomes both an observable on the store object, and a &quot;property&quot; on the proxy object.</p>\n<h4 id="example-inlined-adapter">Example: Inlined adapter</h4>\n<pre><code class="language-tsx">export const MyComponent = () =&gt; {\n  const [name, nameStore] = useAdapt([&#39;name&#39;, &#39;John&#39;], {\n    concat: (state, payload: string) =&gt; state + payload,\n    selectors: {\n      length: state =&gt; state.length,\n    },\n  });\n\n  // Shows &#39;John&#39; and 4 first\n  // Shows &#39;Johnsh&#39; and 6 when the &quot;Concat&quot; button is clicked\n  // Shows &#39;John&#39; and 4 again when the &quot;Reset&quot; button is clicked\n  return (\n    &lt;&gt;\n      &lt;div&gt;{name.state}&lt;/div&gt;\n      &lt;div&gt;{name.length}&lt;/div&gt;\n      &lt;button onClick={() =&gt; nameStore.concat(&#39;sh&#39;)}&gt;Concat&lt;/button&gt;\n      &lt;button onClick={() =&gt; nameStore.reset()}&gt;Reset&lt;/button&gt;\n    &lt;/&gt;\n  );\n};\n</code></pre>\n<h3 id="overload-3">Overload 3</h3>\n<p>  <code>useAdapt([path, initialState], sources)</code></p>\n<p>  Sources allow the store to react to external events. There are 3 possible ways sources can be defined:</p>\n<h5 id="1-a-source-can-be-a-single-source-or-observableactionstate-when-the-source-emits-it-triggers-the-stores-set-method-with-the-payload">1. A source can be a single <a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/rxjs#source\'})); void(0)"><code>Source</code></a> or <a href="https://rxjs.dev/guide/observable"><code>Observable</code></a>&lt;<a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/core#action\'})); void(0)"><code>Action</code></a>&lt;<code>State</code>&gt;&gt;. When the source emits, it triggers the store&#39;s <code>set</code> method with the payload.</h5>\n<h4 id="example-single-source">Example: Single source</h4>\n<pre><code class="language-tsx">const nameChange$ = new Source&lt;string&gt;(&#39;nameChange$&#39;);\n\nexport const MyComponent = () =&gt; {\n  const [name] = useAdapt([&#39;name&#39;, &#39;John&#39;], nameChange$);\n\n  // Shows &#39;John&#39; first\n  // Shows &#39;Johnsh&#39; when the &quot;Set&quot; button is clicked\n  return (\n    &lt;&gt;\n      &lt;div&gt;{name.state}&lt;/div&gt;\n      &lt;button onClick={() =&gt; nameChange$.next(&#39;Johnsh&#39;)}&gt;Set&lt;/button&gt;\n    &lt;/&gt;\n  );\n};\n</code></pre>\n<h5 id="2-a-source-can-be-an-array-of-source-or-observableactionstate-when-any-of-the-sources-emit-it-triggers-the-stores-set-method-with-the-payload">2. A source can be an array of <a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/rxjs#source\'})); void(0)"><code>Source</code></a> or <a href="https://rxjs.dev/guide/observable"><code>Observable</code></a>&lt;<a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/core#action\'})); void(0)"><code>Action</code></a>&lt;<code>State</code>&gt;&gt;. When any of the sources emit, it triggers the store&#39;s <code>set</code> method with the payload.</h5>\n<h4 id="example-array-of-sources">Example: Array of sources</h4>\n<pre><code class="language-tsx">const nameChange$ = new Source&lt;string&gt;(&#39;nameChange$&#39;);\nconst nameChange2$ = new Source&lt;string&gt;(&#39;nameChange2$&#39;);\n\nconst MyComponent = () =&gt; {\n  const [name] = useAdapt([&#39;name&#39;, &#39;John&#39;], [nameChange$, nameChange2$]);\n\n  // Shows &#39;John&#39; first\n  // Shows &#39;Johnsh&#39; when the &quot;Set&quot; button is clicked\n  // Shows &#39;Johnsh2&#39; when the &quot;Set2&quot; button is clicked\n  return (\n    &lt;&gt;\n      &lt;div&gt;{name.state}&lt;/div&gt;\n      &lt;button onClick={() =&gt; nameChange$.next(&#39;Johnsh&#39;)}&gt;Set&lt;/button&gt;\n      &lt;button onClick={() =&gt; nameChange2$.next(&#39;Johnsh2&#39;)}&gt;Set2&lt;/button&gt;\n    &lt;/&gt;\n  );\n};\n</code></pre>\n<h5 id="3-a-source-can-be-an-object-with-keys-that-match-the-names-of-the-stores-reactions-with-a-corresponding-source-or-array-of-sources-that-trigger-the-stores-reaction-with-the-payload">3. A source can be an object with keys that match the names of the store&#39;s reactions, with a corresponding source or array of sources that trigger the store&#39;s reaction with the payload.</h5>\n<h4 id="example-object-of-sources">Example: Object of sources</h4>\n<pre><code class="language-tsx">const nameChange$ = new Source&lt;string&gt;(&#39;nameChange$&#39;);\nconst nameReset$ = new Source&lt;void&gt;(&#39;nameReset$&#39;);\n\nconst MyComponent = () =&gt; {\n  const [name] = useAdapt([&#39;name&#39;, &#39;John&#39;], {\n    set: nameChange$,\n    reset: [nameReset$], // Can be array of sources too\n  });\n\n  // Shows &#39;John&#39; first\n  // Shows &#39;Johnsh&#39; when the &quot;Set&quot; button is clicked\n  // Shows &#39;John&#39; again when the &quot;Reset&quot; button is clicked\n  return (\n    &lt;&gt;\n      &lt;div&gt;{name.state}&lt;/div&gt;\n      &lt;button onClick={() =&gt; nameChange$.next(&#39;Johnsh&#39;)}&gt;Set&lt;/button&gt;\n      &lt;button onClick={() =&gt; nameReset$.next()}&gt;Reset&lt;/button&gt;\n    &lt;/&gt;\n  );\n};\n</code></pre>\n<p>  Each selector&#39;s observable chains off of all the sources passed into the store. For example, if one of your sources\n  is an observable of an HTTP request, that request will triggered as soon as you call <code>useAdapt</code> or\n  subscribe to any of the selector observables from the store. If necessary, you can access store selectors that do not\n  chain off of any sources by using <a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/docs/rxjs#stateadaptwatch\'})); void(0)"><code>StateAdapt.watch</code></a>.</p>\n<h3 id="overload-4">Overload 4</h3>\n<p>  <code>useAdapt([path, initialState, adapter], sources)</code></p>\n<p>  The adapter and sources can be combined in the same overload.</p>\n<h4 id="example-adapter-and-sources">Example: Adapter and sources</h4>\n<pre><code class="language-tsx">const nameChange$ = new Source&lt;string&gt;(&#39;nameChange$&#39;);\nconst nameConcat$ = new Source&lt;string&gt;(&#39;nameConcat$&#39;);\n\nconst nameAdapter = createAdapter&lt;string&gt;()({\n  concat: (state, payload: string) =&gt; state + payload,\n});\n\nconst MyComponent = () =&gt; {\n  const [name] = useAdapt([&#39;name&#39;, &#39;John&#39;, nameAdapter], {\n    set: nameChange$,\n    concat: nameConcat$,\n  });\n\n  // Shows &#39;John&#39; first\n  // Shows &#39;Johnsh&#39; when the &quot;Set&quot; button is clicked\n  // Shows &#39;Johnshsh&#39; when the &quot;Concat&quot; button is clicked // Example suggested by Copilot :)\n  return (\n    &lt;&gt;\n      &lt;div&gt;{name.state}&lt;/div&gt;\n      &lt;button onClick={() =&gt; nameChange$.next(&#39;Johnsh&#39;)}&gt;Set&lt;/button&gt;\n      &lt;button onClick={() =&gt; nameConcat$.next(&#39;sh&#39;)}&gt;Concat&lt;/button&gt;\n    &lt;/&gt;\n  );\n};\n</code></pre>\n'}}return o.\u0275fac=function(n){return new(n||o)},o.\u0275cmp=t.Xpm({type:o,selectors:[["sa-docs-react"]],standalone:!0,features:[t.jDz],decls:2,vars:1,consts:[[3,"html"]],template:function(n,h){1&n&&(t.TgZ(0,"sa-content"),t._UZ(1,"sa-html",0),t.qZA()),2&n&&(t.xp6(1),t.Q6J("html",h.html))},dependencies:[c.S,r.XB],encapsulation:2}),o})()}}]);