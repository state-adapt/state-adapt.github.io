"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[946],{2946:(u,r,t)=>{t.r(r),t.d(r,{AdaptersComponent:()=>d});var s=t(1496),i=t(2309),p=t(3532),e=t(5e3);let d=(()=>{class n{constructor(){this.md="# Adapters\n\n- [Overview](/concepts/adapters#overview)\n- [State Changes](/concepts/adapters#state-changes)\n- [Selectors](/concepts/adapters#selectors)\n- [`createAdapter`](/concepts/adapters#createadapter)\n- [Extending Adapters](/concepts/adapters#extending-adapters)\n- [`createSelectors`](/concepts/adapters#createselectors)\n- [Adapter Creator Libraries](/concepts/adapters#adapter-creator-libraries)\n\n## Overview\n\nAdapters are objects containing 2 kinds of reusable state management patterns: State changes and selectors.\n\n## State Changes\n\nState change functions are pure functions that implement ways state can change. They take 3 arguments and return a new state:\n\n```typescript\n(\n  state, // Current state\n  payload, // Data needed to calculate new state\n  initialState, // State the adapter was initialized with\n) => ({...state}), // New state\n```\n\n## Selectors\n\nSelectors are pure functions that calculate derived state or just return a specific piece of state. They take one argument (`State`) and return any type:\n\n```typescript\nstate => state.property,\n```\n\nSince these functions are only referenced and never called in your code, the convention is to name them nouns instead of verbs (e.g. `state` instead of `getState`). Another reason is explained in [`createSelectors`](/concepts/adapters#createselectors).\n\n## `createAdapter`\n\ncreateAdapter provides type inference when creating state adapters, which is convenient because every state change and selector starts with the same type (`State`), and every state change returns that type as well. Here is an example using createAdapter:\n\n```typescript\nimport { createAdapter } from '@state-adapt/core';\n\nconst numberAdapter = createAdapter<number>()({\n  // Notice the first empty call\u2014TypeScript requires it\n  add: (state, n: number) => state + n,\n  subtract: (state, n: number) => state - n,\n  selectors: {\n    negative: state => state * -1,\n  },\n});\n```\n\nDefining selectors is optional.\n\nEvery adapter comes with 4 default state reactions:\n\n`set` replaces the old state with a new one\n\n`update` replaces specific properties of the old state by spreading the object passed in\n\n`reset` resets to the original state the adapter was initialized with\n\n`noop` does nothing; it just allows sources to log in Redux Devtools\n\nEvery adapter also comes with a default selector:\n\n`state` returns the top-level state value\n\n## Extending Adapters\n\nYou can extend the functionality of existing adapters when creating new adapters. Here is an example that extends the number adapter from above:\n\n```typescript\nimport { createAdapter } from '@state-adapt/core';\nimport { numberAdapter } from './number.adapter';\n\nconst numberStringAdapter = createAdapter<number>()({\n  ...numberAdapter,\n  addFromStr: (state, str: string) => numberAdapter.add(state, +str),\n  selectors: {\n    ...numberAdapter.selectors,\n    stateStr: state => state.toString(),\n  },\n});\n```\n\n## `createSelectors`\n\n`createAdapter` memoizes selectors passed into the `selectors` property, but it only does so shallowly. `createSelectors` provides full selector memoization and a default `state` selector (after the first argument). It takes up to 7 selector objects as arguments, each one receiving all of the selectors from the previous selector objects.\n\n```typescript\nimport { createSelectors, createAdapter } from '@state-adapt/core';\n\nconst selectors = createSelectors<string>()(\n  {\n    reverse: s => s.split('').reverse().join(''),\n  },\n  {\n    isPalendrome: s => s.reverse === s.state,\n  },\n);\n\nconst stringAdapter = createAdapter<string>()({ selectors });\n```\n\nReuse selectors from anywhere:\n\n```typescript\nimport { createAdapter, createSelectors } from '@state-adapt/core';\nimport { numberAdapter } from './number.adapter';\n\nconst selectors = createSelectors(numberAdapter.selectors, {\n  negative: s => s.negative.toString(),\n});\n\nconst numberStringAdapter = createAdapter<number>()({\n  ...numberAdapter,\n  selectors,\n});\n```\n\n`s` is typed the same as the selectors object passed in as the first argument, except using the return type of each selector instead of the selector itself. Internally, `createSelectors` uses a `Proxy` to detect which selectors your new selector functions are accessing in order memoize them efficiently. You could think of `s` as referencing either the selectors object you passed in, or a derived state object created by calling those selectors for each object key. This dual reference is why the convention is to name it `s` instead of either `selectors` or `state`.\n\n`createSelectors` is another reason for naming selectors as nouns instead of verbs: Either it would need to do extra, unnecessary processing to add `'get'`s in the `Proxy` property accessor method to find the correct selectors, or developers would need to treat verbs as nouns in their selector functions, which would be awkward: `s => s.getNegative.toString()`.\n\nNote: If you get this TypeScript error when using the output of `createSelectors` in an adapter:\n\n```\nThe inferred type of this node exceeds the maximum length the compiler will serialize. An explicit type annotation is needed.\n```\n\nAll you have to do is spread the selectors into a new object:\n\n```typescript\nconst numberStringAdapter = createAdapter<number>()({\n  ...numberAdapter,\n  selectors: { ...selectors },\n});\n```\n\nThis forces TypeScript to break the nested type references created in `createSelectors` and understand `selectors` as a flat object instead.\n\n## Adapter Creator Libraries\n\nComing soon\n"}}return n.\u0275fac=function(a){return new(a||n)},n.\u0275cmp=e.Xpm({type:n,selectors:[["state-adapt-adapters"]],standalone:!0,features:[e.jDz],decls:6,vars:2,consts:[[3,"data"],["link","/concepts/sources"],["link","/concepts/stores",3,"right"]],template:function(a,l){1&a&&(e.TgZ(0,"state-adapt-content"),e._UZ(1,"markdown",0),e.TgZ(2,"state-adapt-nav-tile",1),e._uU(3,"Sources"),e.qZA(),e.TgZ(4,"state-adapt-nav-tile",2),e._uU(5," Stores "),e.qZA()()),2&a&&(e.xp6(1),e.Q6J("data",l.md),e.xp6(3),e.Q6J("right",!0))},dependencies:[i.S,s.JP,s.lF,p.c],encapsulation:2}),n})()}}]);