"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[830],{6830:(l,a,t)=>{t.r(a),t.d(a,{ConceptsOverviewComponent:()=>d});var o=t(1496),p=t(2309),i=t(3532),e=t(5e3);let d=(()=>{class s{constructor(){this.md="# StateAdapt Conceptual Overview\n\nStateAdapt has 3 main concepts: Sources, adapters and stores.\n\n## [Sources](/concepts/sources)\n\n[Sources](/concepts/sources) are where asynchronous data enters applications. Examples are\n\n- User input\n- Data arriving from a server\n- A timer completing\n\n## [Adapters](/concepts/adapters)\n\n[Adapters](/concepts/adapters) are objects containing 2 kinds of reusable state management patterns:\n\n- State changes (pure functions that implement ways state can change)\n- Selectors (pure functions that calculate derived state or just return a specific piece of state)\n\n## [Stores](/concepts/stores)\n\n[Stores](/concepts/stores) do 4 things:\n\n- Define initial state and an adapter to manage it\n- Connect sources to adapter state changes\n- Use the adapter's selectors to create observables of the selectors' results. These observables chain off the sources so subscriptions are propagated\n- Use the adapter's state changes to create synthetic sources for simple, single-store state changes. These are made available as part of the store, so DOM event handlers can call them. See [Synthetic Sources](/concepts/sources#synthetic-sources).\n"}}return s.\u0275fac=function(n){return new(n||s)},s.\u0275cmp=e.Xpm({type:s,selectors:[["state-adapt-concepts-overview"]],standalone:!0,features:[e.jDz],decls:4,vars:2,consts:[[3,"data"],["link","/concepts/sources",3,"right"]],template:function(n,u){1&n&&(e.TgZ(0,"state-adapt-content"),e._UZ(1,"markdown",0),e.TgZ(2,"state-adapt-nav-tile",1),e._uU(3," Sources "),e.qZA()()),2&n&&(e.xp6(1),e.Q6J("data",u.md),e.xp6(1),e.Q6J("right",!0))},dependencies:[p.S,o.JP,o.lF,i.c],encapsulation:2}),s})()}}]);