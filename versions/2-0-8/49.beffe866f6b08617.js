"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[49],{1049:(u,a,t)=>{t.r(a),t.d(a,{AdaptersComponent:()=>l});var o=t(6087),i=t(1917),c=t(2309),e=t(4650);let l=(()=>{class s{constructor(){this.html='<h1 id="adapters">Adapters</h1>\n<ul class="bx--list--unordered"><li class="bx--list__item"><a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/concepts/adapters#overview\'})); void(0)">Overview</a></li><li class="bx--list__item"><a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/concepts/adapters#state-changes\'})); void(0)">State Changes</a></li><li class="bx--list__item"><a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/concepts/adapters#selectors\'})); void(0)">Selectors</a></li><li class="bx--list__item"><a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/concepts/adapters#createadapter\'})); void(0)"><code>createAdapter</code></a></li><li class="bx--list__item"><a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/concepts/adapters#buildadapter\'})); void(0)"><code>buildAdapter</code></a></li><li class="bx--list__item"><a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/concepts/adapters#joinadapters\'})); void(0)"><code>joinAdapters</code></a></li><li class="bx--list__item"><a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/concepts/adapters#adapter-creator-libraries\'})); void(0)">Adapter Creator Libraries</a></li></ul><h2 id="buildadapter"><code>buildAdapter</code></h2>\n<p>Let&#39;s look at each of these.</p>\n<h3 id="1-selectors">1. Selectors</h3>\n\x3c!-- Advice --\x3e\n<p>Selectors should be defined before anything else, since they can be used in reactions, and it helps to have a consistent pattern to make things easily findable.</p>\n\x3c!-- Justification --\x3e\n<p>Why <code>s</code>? Well, should the object (<code>s</code>) passed into each selector function be named <code>selectors</code>, <code>state</code> or <code>selectorState</code>? In reality it&#39;s just a proxy, so none of these really make sense. So, the convention is <code>s</code>, since it&#39;s short and the only letter all the possible meanings share.</p>\n\x3c!-- Justification --\x3e\n<p>Note 1: <a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/concepts/adapters#buildadapter\'})); void(0)"><code>buildAdapter</code></a> is another reason for naming selectors as nouns instead of verbs: Either it would need to do extra, unnecessary processing to add <code>&#39;get&#39;</code>s in the <code>Proxy</code> property accessor method to find the correct selectors, or developers would need to treat verbs as nouns in their selector functions, which would be awkward: <code>s =&gt; s.getNegative.toString()</code>.</p>\n\x3c!-- Persuasion --\x3e\n<p>Note 2: Here&#39;s how the above selectors would have been defined using a Redux-like <code>createSelector</code> function:</p>\n\x3c!-- Persuasion --\x3e\n<pre><code class="language-tsx">import { createSelector } from &#39;reselect&#39;; // or whatever\n\n// Need a function that returns the selector in order to be\n// reusable and independently memoized:\nconst getSelectReverse = (selectState: (state: string) =&gt; string) =&gt;\n  createSelector(selectState, state =&gt; state.split(&#39;&#39;).reverse().join(&#39;&#39;));\n\nconst getSelectIsPalendrome = (selectState: (state: string) =&gt; string) =&gt;\n  createSelector(\n    selectState,\n    getSelectReverse(selectState),\n    (state, reverse) =&gt; state === reverse,\n  );\n\n// ...\n// Before using for some specific state\nconst selectReverse = getSelectReverse(selectSpecificState);\nconst selectIsPalendrome = getSelectIsPalendrome(selectSpecificState);\n</code></pre>\n\x3c!-- Persuasion --\x3e\n<p>or in RxJS:</p>\n<pre><code class="language-tsx">import { map, combineLatest, distinctUntilChanged } from &#39;rxjs&#39;;\n\nconst getReverse = (state: string) =&gt; state.split(&#39;&#39;).reverse().join(&#39;&#39;);\nconst getIsPalendrome = ([state, reverse]: [string, string]) =&gt;\n  state === reverse;\n\n// ...\n// Using in a specific piece of state\nconst reverse$ = specificState$.pipe(map(getReverse), distinctUntilChanged());\nconst isPalendrome$ = combineLatest([specificState$, reverse$]).pipe(\n  map(getIsPalendrome),\n  distinctUntilChanged(),\n);\n</code></pre>\n<h3 id="3-grouped-reactions">3. Grouped Reactions</h3>\n\x3c!-- Justification --\x3e\n<p>The reason grouped reactions are useful is because if you tried to reuse <code>setCoolNumber</code> and <code>setWeirdNumber</code>, you would end up calculating 2 new states:</p>\n<pre><code class="language-typescript">const numbersAdapter = buildAdapter&lt;NumbersState&gt;()({\n  setCoolNumber: (state, newCoolNumber: number) =&gt; ({\n    ...state,\n    coolNumber: newCoolNumber,\n  }),\n  setWeirdNumber: (state, newWeirdNumber: number) =&gt; ({\n    ...state,\n    weirdNumber: newWeirdNumber,\n  }),\n})(([selectors, reactions]) =&gt; ({\n  setBothNumbers: (state, newNumber: number) =&gt;\n    reactions.setWeirdNumber(reactions.setCoolNumber(state)),\n}))();\n</code></pre>\n\x3c!-- Justification --\x3e\n<p>If you tried to calculate a single new state, you would override properties from the first change with the unchanged properties from the second change, so passing the result of one reaction to the other is the only way to ensure consistent state without duplicating state change logic in the new state reaction. But this is inefficient.</p>\n\x3c!-- Justification --\x3e\n<p>State change groups are able to efficiently calculate a single new state.</p>\n<h2 id="joinadapters"><code>joinAdapters</code></h2>\n<h2 id="adapter-creator-libraries">Adapter Creator Libraries</h2>\n<p>State adapters allow state management patterns to be easily reusable.</p>\n<p>Similar to how components enabled awesome component libraries for modern UI frameworks, state adapters open up the opportunity for adapter libraries.</p>\n<p>StateAdapt has created a few core adapters, and plans to create many more. See the <a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/adapters/core\'})); void(0)">core adapters documentation</a>.</p>\n'}}return s.\u0275fac=function(n){return new(n||s)},s.\u0275cmp=e.Xpm({type:s,selectors:[["sa-adapters"]],standalone:!0,features:[e.jDz],decls:8,vars:1,consts:[[3,"html"],["routerLink","/concepts/stores"],["routerLink","/concepts/sources"]],template:function(n,p){1&n&&(e.TgZ(0,"sa-content"),e._UZ(1,"sa-html",0),e.TgZ(2,"h2")(3,"a",1),e._uU(4,"Next: Stores"),e.qZA()(),e.TgZ(5,"h2")(6,"a",2),e._uU(7,"Previous: Sources"),e.qZA()()()),2&n&&(e.xp6(1),e.Q6J("html",p.html))},dependencies:[o.Bz,o.yS,c.S,i.XB],encapsulation:2}),s})()}}]);