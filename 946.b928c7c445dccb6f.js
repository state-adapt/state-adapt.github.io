"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[946],{2946:(u,r,t)=>{t.r(r),t.d(r,{AdaptersComponent:()=>p});var s=t(5927),o=t(8176),c=t(2309),e=t(4650);let p=(()=>{class n{constructor(){this.md="# Adapters\n\n- [Overview](/concepts/adapters#overview)\n- [State Changes](/concepts/adapters#state-changes)\n- [Selectors](/concepts/adapters#selectors)\n- [`createAdapter`](/concepts/adapters#createadapter)\n- [Extending Adapters](/concepts/adapters#extending-adapters)\n- [`createSelectors`](/concepts/adapters#createselectors)\n- [`buildSelectors`](/concepts/adapters#buildselectors)\n- [`buildAdapter`](/concepts/adapters#buildadapter)\n- [`joinAdapters`](/concepts/adapters#joinadapters)\n- [`mapPayloads`](/concepts/adapters#mappayloads)\n- [TypeScript Errors](/concepts/adapters#typescript-errors)\n- [Adapter Creator Libraries](/concepts/adapters#adapter-creator-libraries)\n\n## Overview\n\nAdapters are objects containing 2 kinds of reusable state management patterns: State changes and selectors.\n\n## State Changes\n\nState change functions are pure functions that implement ways state can change. They take 3 arguments and return a new state:\n\n```typescript\n(\n  state, // Current state\n  payload, // Data needed to calculate new state\n  initialState, // State the adapter was initialized with\n) => ({...state}), // New state\n```\n\n## Selectors\n\nSelectors are pure functions that calculate derived state or just return a specific piece of state. They take one argument (`State`) and return any type:\n\n```typescript\nstate => state.property,\n```\n\nSince these functions are only referenced and never called in your code, the convention is to name them nouns instead of verbs (e.g. `state` instead of `getState`). Another reason is explained in [`createSelectors`](/concepts/adapters#createselectors).\n\n## `createAdapter`\n\ncreateAdapter provides type inference when creating state adapters, which is convenient because every state change and selector starts with the same type (`State`), and every state change returns that type as well. Here is an example using createAdapter:\n\n```typescript\nimport { createAdapter } from '@state-adapt/core';\n\nconst numberAdapter = createAdapter<number>()({\n  // Notice the first empty call\u2014TypeScript requires it\n  add: (state, n: number) => state + n,\n  subtract: (state, n: number) => state - n,\n  selectors: {\n    negative: state => state * -1,\n  },\n});\n```\n\nDefining selectors is optional.\n\nEvery adapter comes with 4 default state reactions:\n\n`set` replaces the old state with a new one\n\n`update` replaces specific properties of the old state by spreading the object passed in\n\n`reset` resets to the original state the adapter was initialized with\n\n`noop` does nothing; it just allows sources to log in Redux Devtools\n\nEvery adapter also comes with a default selector:\n\n`state` returns the top-level state value\n\n## Extending Adapters\n\nYou can extend the functionality of existing adapters when creating new adapters. Here is an example that extends the number adapter from above:\n\n```typescript\nimport { createAdapter } from '@state-adapt/core';\nimport { numberAdapter } from './number.adapter';\n\nconst numberStringAdapter = createAdapter<number>()({\n  ...numberAdapter,\n  addFromStr: (state, str: string) => numberAdapter.add(state, +str),\n  selectors: {\n    ...numberAdapter.selectors,\n    stateStr: state => state.toString(),\n  },\n});\n```\n\n## `createSelectors`\n\n`createSelectors` has been deprecated in favor of [`buildSelectors`](/concepts/adapters#buildselectors)\n\n[`createAdapter`](/concepts/adapters#createadapter) memoizes selectors passed into the `selectors` property, but it only does so shallowly. `createSelectors` provides full selector memoization and a default `state` selector (after the first argument). It takes up to 7 selector objects as arguments, each one receiving all of the selectors from the previous selector objects.\n\n```typescript\nimport { createSelectors, createAdapter } from '@state-adapt/core';\n\nconst selectors = createSelectors<string>()(\n  {\n    reverse: s => s.split('').reverse().join(''),\n  },\n  {\n    isPalendrome: s => s.reverse === s.state,\n  },\n);\n\nconst stringAdapter = createAdapter<string>()({ selectors });\n```\n\nReuse selectors from anywhere:\n\n```typescript\nimport { createAdapter, createSelectors } from '@state-adapt/core';\nimport { numberAdapter } from './number.adapter';\n\nconst selectors = createSelectors(numberAdapter.selectors, {\n  negative: s => s.negative.toString(),\n});\n\nconst numberStringAdapter = createAdapter<number>()({\n  ...numberAdapter,\n  selectors,\n});\n```\n\n`s` is typed the same as the selectors object passed in as the first argument, except using the return type of each selector instead of the selector itself. Internally, `createSelectors` uses a `Proxy` to detect which selectors your new selector functions are accessing in order memoize them efficiently. You could think of `s` as referencing either the selectors object you passed in, or a derived state object created by calling those selectors for each object key. This dual reference is why the convention is to name it `s` instead of either `selectors` or `state`.\n\n`createSelectors` is another reason for naming selectors as nouns instead of verbs: Either it would need to do extra, unnecessary processing to add `'get'`s in the `Proxy` property accessor method to find the correct selectors, or developers would need to treat verbs as nouns in their selector functions, which would be awkward: `s => s.getNegative.toString()`.\n\nNote: If you get this TypeScript error when using the output of `createSelectors` in an adapter:\n\n```\nThe inferred type of this node exceeds the maximum length the compiler will serialize. An explicit type annotation is needed.\n```\n\nOr this error:\n\n```\nType instantiation is excessively deep and possibly infinite.\n```\n\nAll you have to do is spread the selectors into a new object:\n\n```typescript\nconst numberStringAdapter = createAdapter<number>()({\n  ...numberAdapter,\n  selectors: { ...selectors },\n});\n```\n\nThis forces TypeScript to break the nested type references created in `createSelectors` and understand `selectors` as a flat object instead. If your selector chain is long enough, you might need to break it up into multiple calls to `createSelectors`.\n\n## `buildSelectors`\n\n[`createAdapter`](/concepts/adapters#createadapter) memoizes selectors passed into the `selectors` property, but it only does so shallowly. [`buildSelectors`](/concepts/adapters#buildselectors) provides full selector memoization and a default `state` selector (after the first call). It takes initial selectors in the first call, which receive a state object to select against, and it returns a function that can be called successively with more selectors, each selecting against the return values from all selectors previously passed in. To return all the selectors combined, call it a final time with no parameter:\n\n```typescript\nimport { createSelectors, createAdapter } from '@state-adapt/core';\n\nconst selectors = buildSelectors<string>()({\n  reverse: s => s.split('').reverse().join(''),\n})({\n  isPalendrome: s => s.reverse === s.state,\n})();\n\nconst stringAdapter = createAdapter<string>()({ selectors });\n```\n\nReuse selectors from anywhere:\n\n```typescript\nimport { createAdapter, createSelectors } from '@state-adapt/core';\nimport { numberAdapter } from './number.adapter';\n\nconst selectors = buildSelectors<number>()(numberAdapter.selectors)({\n  negative: s => s.negative.toString(),\n})();\n\nconst numberStringAdapter = createAdapter<number>()({\n  ...numberAdapter,\n  selectors,\n});\n```\n\n`s` is typed the same as the selectors object passed in as the first argument, except using the return type of each selector instead of the selector itself. Internally, [`buildSelectors`](/concepts/adapters#buildselectors) uses a `Proxy` to detect which selectors your new selector functions are accessing in order memoize them efficiently. You could think of `s` as referencing either the selectors object you passed in, or a derived state object created by calling those selectors for each object key. This dual reference is why the convention is to name it `s` instead of either `selectors` or `state`.\n\n[`buildSelectors`](/concepts/adapters#buildselectors) is another reason for naming selectors as nouns instead of verbs: Either it would need to do extra, unnecessary processing to add `'get'`s in the `Proxy` property accessor method to find the correct selectors, or developers would need to treat verbs as nouns in their selector functions, which would be awkward: `s => s.getNegative.toString()`.\n\n## `buildAdapter`\n\n`buildAdapter` uses similar syntax to that of [`buildSelectors`](/concepts/adapters#buildselectors): You call it with an initial adapter, then call it again and again with more objects inheriting from previous objects, until a final empty call `()` to get the final built adapter:\n\n```typescript\nimport { buildAdapter } from '@state-adapt/core';\nimport { numberAdapter } from './number.adapter';\n\nconst numberStringAdapter = buildAdapter<number>()(numberAdapter)({\n  negative: s => s.negative.toString(),\n})();\n// Same result as the buildSelectors example above\n```\n\n[`buildAdapter`](/concepts/adapters#buildadapter) takes 3 possible arguments in each call: A selectors object, like in the example above or the example in [`buildselectors`](/concepts/adapters#buildselectors); a function taking in an array of selectors and reactions and returning new reactions; or a nested object defining grouped state reactions.\n\nThe function returning new reactions can be used like this:\n\n```typescript\nimport { buildAdapter } from '@state-adapt/core';\nimport { numberAdapter } from './number.adapter';\n\nconst numberStringAdapter = buildAdapter<number>()(numberAdapter)({\n  negativeStr: s => s.negative.toString(),\n})(([selectors, reactions]) => ({\n  setToNegative: state => selectors.negative(state),\n}))();\n```\n\n`setToNegative` becomes a reaction on `numberStringAdapter` that multiplies the state by `-1` (the return of `selectors.negative(state)`).\n\nThe nested object defining grouped state reactions is for nested states. Let's say you had an adapter like this:\n\n```typescript\nimport { buildAdapter } from '@state-adapt/core';\nimport { numberAdapter } from './number.adapter';\n\ninterface NumbersState {\n  coolNumber: number;\n  weirdNumber: number;\n}\n\nconst numbersAdapter = buildAdapter<NumbersState>()({\n  setCoolNumber: (state, newCoolNumber: number) => ({\n    ...state,\n    coolNumber: newCoolNumber,\n  }),\n  setWeirdNumber: (state, newWeirdNumber: number) => ({\n    ...state,\n    weirdNumber: newWeirdNumber,\n  }),\n})();\n```\n\nYou could define a group state change that sets both `coolNumber` and `weirdNumber` like this:\n\n```typescript\nconst numbersAdapter = buildAdapter<NumbersState>()({\n  setCoolNumber: (state, newCoolNumber: number) => ({\n    ...state,\n    coolNumber: newCoolNumber,\n  }),\n  setWeirdNumber: (state, newWeirdNumber: number) => ({\n    ...state,\n    weirdNumber: newWeirdNumber,\n  }),\n})({\n  setBothNumbers: {\n    coolNumber: numberAdapter.set,\n    weirdNumber: numberAdapter.set,\n  },\n})();\n```\n\n`setBothNumbers` becomes a reaction on `numbersAdapter` that sets both `coolNumber` and `weirdNumber` to the same payload passed into `setBothNumbers`. Every reaction passed into the same grouped reaction must take the same payload type.\n\nThe reason grouped reactions are useful is because if you tried to reuse `setCoolNumber` and `setWeirdNumber`, you would end up calculating a new state twice:\n\n```typescript\nconst numbersAdapter = buildAdapter<NumbersState>()({\n  setCoolNumber: (state, newCoolNumber: number) => ({\n    ...state,\n    coolNumber: newCoolNumber,\n  }),\n  setWeirdNumber: (state, newWeirdNumber: number) => ({\n    ...state,\n    weirdNumber: newWeirdNumber,\n  }),\n})(([selectors, reactions]) => ({\n  setBothNumbers: (state, newNumber: number) =>\n    reactions.setWeirdNumber(reactions.setCoolNumber(state)),\n}))();\n```\n\nIf you tried to calculate a single new state, you would override properties from the first change with the unchanged properties from the second change, so passing the result of one reaction to the other is the only way to ensure consistent state without duplicating state change logic in the new state reaction. But this is inefficient.\n\nState change groups are able to efficiently calculate a single new state.\n\n## `joinAdapters`\n\nSimilar data types will have similar state management logic. Take this example from [`buildAdapter`](/concepts/adapters#buildadapter):\n\n```typescript\nimport { buildAdapter } from '@state-adapt/core';\nimport { numberAdapter } from './number.adapter';\n\ninterface NumbersState {\n  coolNumber: number;\n  weirdNumber: number;\n}\n\nconst numbersAdapter = buildAdapter<NumbersState>()({\n  setCoolNumber: (state, newCoolNumber: number) => ({\n    ...state,\n    coolNumber: newCoolNumber,\n  }),\n  setWeirdNumber: (state, newWeirdNumber: number) => ({\n    ...state,\n    weirdNumber: newWeirdNumber,\n  }),\n})();\n```\n\nSee how both properties are numbers and end up with the same state change? What would be awesome is if we could define individual adapters for these properties and automatically inheret the state changes for those properties in our parent state adapter:\n\n```typescript\nimport { joinAdapters } from '@state-adapt/core';\nimport { numberAdapter } from './number.adapter';\n\ninterface NumbersState {\n  coolNumber: number;\n  weirdNumber: number;\n}\n\nconst numbersAdapter = joinAdapters<NumbersState>()({\n  coolNumber: numberAdapter,\n  weirdNumber: numberAdapter,\n})();\n```\n\nThis will produce the same adapter as in the previous code snippet.\n\n[`joinAdapters`](/concepts/adapters#joinadapters) returns the same builder function as [`buildAdapter`](/concepts/adapters#buildadapter), so you can use it like this:\n\n```typescript\nimport { joinAdapters } from '@state-adapt/core';\nimport { numberAdapter } from './number.adapter';\n\ninterface NumbersState {\n  coolNumber: number;\n  weirdNumber: number;\n}\n\nconst numbersAdapter = joinAdapters<NumbersState>()({\n  coolNumber: numberAdapter,\n  weirdNumber: numberAdapter,\n})({\n  setBothNumbers: {\n    coolNumber: numberAdapter.set,\n    weirdNumber: numberAdapter.set,\n  },\n})();\n```\n\nAll selectors from `number` adapter (see [`createAdapter`](/concepts/adapters#createadapter)) will get prepended with the namespace we've defined. So we get these selectors:\n\n```typescript\n{\n  negativeCoolNumber: state => state.coolNumber * -1,\n  negativeWeirdNumber: state => state.coolNumber * -1,\n}\n```\n\nAll state reactions have the namespace inserted after the first word. So we get these reactions:\n\n```typescript\n{\n  addCoolNumber: (state, n: number) => ({...state, coolNumber: state.coolNumber + n}),\n  subtractCoolNumber: (state, n: number) => ({...state, coolNumber: state.coolNumber - n}),\n  addWeirdNumber: (state, n: number) => ({...state, weirdNumber: state.weirdNumber + n}),\n  subtractWeirdNumber: (state, n: number) => ({...state, weirdNumber: state.weirdNumber - n}),\n}\n```\n\nThis may change in the future to simple prefixing like selectors, depending on what we find as we use this on real-world problems. Here are some example state change names and what they'd end up as with `joinAdapters`:\n\n- `set` => `setFeature`\n- `setLoadingToTrue` => `setFeatureLoadingToTrue`\n- `toggle` => `toggleFeature`\n- `decrementPopulation` => `decrementFeaturePopulation`\n- `setTo5` => `setFeatureTo5`\n\n## `mapPayloads`\n\n`mapPayloads` takes in an object with adapter reactions as the first argument, an object with payload mappers as the second argument, and returns the mapped reactions. For example, if you had this adapter:\n\n```typescript\nconst numberAdapter = createAdapter<number>()({\n  add: (state, n: number) => state + n,\n  subtract: (state, n: number) => state - n,\n  selectors: {\n    negative: state => state * -1,\n  },\n});\n```\n\nYou could change the payloads of any of the reactions with `mapPayloads`:\n\n```typescript\nconst addFromStringAdapter = mapPayloads(numberAdapter, {\n  add: (nStr: string) => +nStr,\n});\n```\n\nThat would would return an object like this:\n\n```typescript\n{\n  add: (state: number, nStr: string) => +nStr,\n}\n```\n\nThis is useful with [`buildAdapter`](/concepts/adapters#buildadapter), because when defining new reactions you only return the new reactions. So you could do something like this:\n\n```typescript\nconst numberAdapter = buildAdapter<number>()({\n  add: (state, n: number) => state + n,\n  subtract: (state, n: number) => state - n,\n  selectors: {\n    negative: state => state * -1,\n  },\n})(([selectors, reactions]) =>\n  mapPayloads(\n    {\n      add5: reactions.add, // add5 expects a payload still\n      add10: reactions.add, // add10 expects a payload still\n      add15: reactions.add, // add15 expects a payload still\n    },\n    {\n      add5: () => 5, // add5 is now a reaction that doesn't take a payload\n      add10: () => 10, // add10 is now a reaction that doesn't take a payload\n      add16: () => 15, // add15 is now a reaction that doesn't take a payload\n    },\n  ),\n)();\n```\n\nThe result would be the same as defining an adapter like this:\n\n```typescript\nconst numberAdapter = createAdapter<number>()({\n  add: (state, n: number) => state + n,\n  add5: state => state + 5,\n  add10: state => state + 10,\n  add15: state => state + 15,\n  subtract: (state, n: number) => state - n,\n  selectors: {\n    negative: state => state * -1,\n  },\n});\n```\n\n[`mapPayloads`](/concepts/adapters#mappayloads) is most useful when you want to define an adapter with ideal payloads, but actually need an adapter that takes in annoying payload types. For example, if you are receiving data from an API, you might want to write an adapter like this:\n\n```typescript\nconst dataAdapter = createAdapter<WithData>()({\n  receiveData: (state, data: Data) => ({ ...state, data }),\n});\n```\n\nBut then you might have an `HTTP` source like this:\n\n```typescript\ninterface ApiData {\n  weirdly: {\n    nested: {\n      response: {\n        shape: {\n          with: {\n            data: Data;\n          };\n        };\n      };\n    };\n  };\n}\n```\n\nYou would like to keep your `dataAdapter` defined how it is, so you can use `mapPayloads` here:\n\n```typescript\nconst dataAdapter = createAdapter<WithData>()({\n  receiveData: (state, data: Data) => ({ ...state, data }),\n});\n\nconst apiDataAdapter = buildAdapter<WithData>()(([s, reactions]) =>\n  mapPayloads(reactions, {\n    receiveData: (data: ApiData) => data.weirdly.nested.response.shape.with.data,\n  }),\n);\n```\n\nThis is preferable over either modifying the simpler `dataAdapter` _or_ modifying the HTTP source observable with `.pipe(map(...))`. Sources should be as simple as possible. Adapters are the perfect place to put mapping logic.\n\n## TypeScript Errors\n\nIf you get this TypeScript error:\n\n```\nThe inferred type of this node exceeds the maximum length the compiler will serialize. An explicit type annotation is needed.\n```\n\nOr this error:\n\n```\nType instantiation is excessively deep and possibly infinite.\n```\n\nYou can try spreading adapters and selectors into a new object:\n\n```typescript\nconst numberAdapter2 = createAdapter<number>()({\n  ...numberAdapter,\n  selectors: { ...selectors },\n});\n```\n\nThis forces TypeScript to break the nested type references created in the various adapter builder functions and understand `selectors` as a flat object instead.\n\nHowever, sometimes even this isn't enough, and you may have to use explicit type annotations. StateAdapt relies heavily on type inference, and that comes at a cost, sometimes more than TypeScript wants to handle.\n\n## Adapter Creator Libraries\n\nComing soon\n"}}return n.\u0275fac=function(a){return new(a||n)},n.\u0275cmp=e.Xpm({type:n,selectors:[["state-adapt-adapters"]],standalone:!0,features:[e.jDz],decls:8,vars:1,consts:[[3,"data"],["routerLink","/concepts/stores"],["routerLink","/concepts/sources"]],template:function(a,l){1&a&&(e.TgZ(0,"state-adapt-content"),e._UZ(1,"markdown",0),e.TgZ(2,"h2")(3,"a",1),e._uU(4,"Next: Stores"),e.qZA()(),e.TgZ(5,"h2")(6,"a",2),e._uU(7,"Previous: Sources"),e.qZA()()()),2&a&&(e.xp6(1),e.Q6J("data",l.md))},dependencies:[s.Bz,s.yS,c.S,o.JP,o.lF],encapsulation:2}),n})()}}]);