"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[946],{2946:(l,r,t)=>{t.r(r),t.d(r,{AdaptersComponent:()=>c});var s=t(5927),o=t(8176),p=t(2309),e=t(4650);let c=(()=>{class n{constructor(){this.md="# Adapters\n\n- [Overview](/concepts/adapters#overview)\n- [State Changes](/concepts/adapters#state-changes)\n- [Selectors](/concepts/adapters#selectors)\n- [`createAdapter`](/concepts/adapters#createadapter)\n- [Extending Adapters](/concepts/adapters#extending-adapters)\n- [`buildAdapter`](/concepts/adapters#buildadapter)\n- [`joinAdapters`](/concepts/adapters#joinadapters)\n- [`mapPayloads`](/concepts/adapters#mappayloads)\n- [Adapter Creator Libraries](/concepts/adapters#adapter-creator-libraries)\n\n## Overview\n\nAdapters are objects containing 2 kinds of reusable state management patterns: State changes and selectors.\n\n## State Changes\n\nState change functions are pure functions that implement ways state can change. They take 3 arguments and return a new state:\n\n```typescript\n(\n  state, // Current state\n  payload, // Data needed to calculate new state\n  initialState, // State the adapter was initialized with\n) => ({ ...state }), // New state\n```\n\n## Selectors\n\nSelectors are pure functions that calculate derived state or just return a specific piece of state. They take one argument (`State`) and return any type:\n\n```typescript\nstate => state.property,\n```\n\nSince these functions are only referenced and never called in your code, the convention is to name them nouns instead of verbs (e.g. `state` instead of `getState`).\n\n## `createAdapter`\n\ncreateAdapter provides type inference when creating state adapters, which is convenient because every state change and selector starts with the same type (`State`), and every state change returns that type as well. Here is an example using createAdapter:\n\n```typescript\nimport { createAdapter } from '@state-adapt/core';\n\nconst numberAdapter = createAdapter<number>()({\n  add: (state, n: number) => state + n,\n  subtract: (state, n: number) => state - n,\n  selectors: {\n    negative: state => state * -1,\n  },\n});\n```\n\nDefining selectors is optional.\n\nEvery adapter comes with 4 default state reactions:\n\n- `set` replaces the old state with a new one\n- `update` replaces specific properties of the old state by spreading the object passed in\n- `reset` resets to the original state the adapter was initialized with\n- `noop` does nothing; it just allows sources to log in Redux Devtools\n\nEvery adapter also comes with a default selector:\n\n- `state` returns the top-level state value\n\n## Extending Adapters\n\nYou can extend the functionality of existing adapters when creating new adapters. Here is an example that extends the number adapter from above:\n\n```typescript\nimport { createAdapter } from '@state-adapt/core';\nimport { numberAdapter } from './number.adapter';\n\nconst numberStringAdapter = createAdapter<number>()({\n  ...numberAdapter,\n  addFromStr: (state, str: string) => numberAdapter.add(state, +str),\n  selectors: {\n    ...numberAdapter.selectors,\n    stateStr: state => state.toString(),\n  },\n});\n```\n\n## `buildAdapter`\n\n`buildAdapter` is called with an initial adapter, then can be called again and again with more objects inheriting from previous objects, until a final empty call `()` to get the final built adapter:\n\n```typescript\nimport { buildAdapter } from '@state-adapt/core';\nimport { numberAdapter } from './number.adapter';\n\nconst numberStringAdapter = buildAdapter<number>()(numberAdapter)({\n  // Define more stuff\n})(([selectors, reactions]) => ({\n  // Define more stuff\n}))({\n  // etc\n})(); // End\n```\n\nThe first call creates a new object, but after that, every object passed in is looped over and used to mutate the original new object.\n\n[`buildAdapter`](/concepts/adapters#buildadapter) takes 3 possible arguments in each call (after the first):\n\n1. A selectors object\n2. A function taking in a tuple of `[selectors, reactions]` and returning new reactions\n3. A nested object defining grouped state reactions\n\nLet's look at each of these.\n\n### 1. Selectors\n\nSelectors should be defined before anything else, since they can be used in reactions, and it helps to have a consistent pattern to make things easily findable.\n\n[`buildAdapter`](/concepts/adapters#buildadapter) provides full selector memoization and a default `state` selector (after the first call). The selectors defined in the first call each receive a state object to select against. Each subsequent selector block has access to all selectors previously defined. To return all the selectors combined into an adapter, call it a final time with no parameter.\n\nExample:\n\n```typescript\nimport { buildAdapter } from '@state-adapt/core';\n\nconst stringAdapter = buildAdapter<string>()()({\n  reverse: s => s.state.split('').reverse().join(''),\n})({\n  isPalendrome: s => s.reverse === s.state,\n})();\n```\n\n`s` is typed as an object with properties with the same names as all the selectors defined previously, and typed with each corresponding selector's return type. Internally, [`buildAdapter`](/concepts/adapters#buildadapter) uses a `Proxy` to detect which selectors your new selector functions are accessing in order memoize them efficiently.\n\nWhy `s`? Well, should the object (`s`) passed into each selector function be named `selectors`, `state` or `selectorState`? In reality it's just a proxy, so none of these really make sense. So, the convention is `s`, since it's short and the only letter all the possible meanings share.\n\nNote 1: [`buildAdapter`](/concepts/adapters#buildadapter) is another reason for naming selectors as nouns instead of verbs: Either it would need to do extra, unnecessary processing to add `'get'`s in the `Proxy` property accessor method to find the correct selectors, or developers would need to treat verbs as nouns in their selector functions, which would be awkward: `s => s.getNegative.toString()`.\n\nNote 2: Here's how the above selectors would have been defined using a Redux-like `createSelector` function:\n\n```tsx\nimport { createSelector } from 'reselect'; // or whatever\n\n// Need a function that returns the selector in order to be\n// reusable and independently memoized:\nconst getSelectReverse = (selectState: (state: string) => string) =>\n  createSelector(selectState, state => state.split('').reverse().join(''));\n\nconst getSelectIsPalendrome = (selectState: (state: string) => string) =>\n  createSelector(\n    selectState,\n    getSelectReverse(selectState),\n    (state, reverse) => state === reverse,\n  );\n\n// ...\n// Before using for some specific state\nconst selectReverse = getSelectReverse(selectSpecificState);\nconst selectIsPalendrome = getSelectIsPalendrome(selectSpecificState);\n```\n\nor in RxJS:\n\n```tsx\nimport { map, combineLatest, distinctUntilChanged } from 'rxjs';\n\nconst getReverse = (state: string) => state.split('').reverse().join('');\nconst getIsPalendrome = ([state, reverse]: [string, string]) =>\n  state === reverse;\n\n// ...\n// Using in a specific piece of state\nconst reverse$ = specificState$.pipe(map(getReverse), distinctUntilChanged());\nconst isPalendrome$ = combineLatest([specificState$, reverse$]).pipe(\n  map(getIsPalendrome),\n  distinctUntilChanged(),\n);\n```\n\n### 2. Reactions\n\nThe function returning new reactions can be used like this:\n\n```typescript\nimport { buildAdapter } from '@state-adapt/core';\nimport { numberAdapter } from './number.adapter';\n\nconst numberStringAdapter = buildAdapter<number>()(numberAdapter)({\n  negativeStr: s => s.negative.toString(),\n})(([selectors, reactions]) => ({\n  setToNegative: state => selectors.negative(state),\n}))();\n```\n\n`setToNegative` becomes a reaction on `numberStringAdapter` that multiplies the state by `-1` (the return of `selectors.negative(state)`).\n\nSelectors used when defining new reactions must be called as functions and will not be memoized. If efficiency is critical, you might want to put the derived state in the action payload for the state change.\n\n### 3. Nested Reactions\n\nThe nested object defining grouped state reactions is for nested states. Let's say you had an adapter like this:\n\n```typescript\nimport { buildAdapter } from '@state-adapt/core';\nimport { numberAdapter } from './number.adapter';\n\ninterface NumbersState {\n  coolNumber: number;\n  weirdNumber: number;\n}\n\nconst numbersAdapter = buildAdapter<NumbersState>()({\n  setCoolNumber: (state, newCoolNumber: number) => ({\n    ...state,\n    coolNumber: newCoolNumber,\n  }),\n  setWeirdNumber: (state, newWeirdNumber: number) => ({\n    ...state,\n    weirdNumber: newWeirdNumber,\n  }),\n})();\n```\n\nYou could define a group state change that sets both `coolNumber` and `weirdNumber` like this:\n\n```typescript\nconst numbersAdapter = buildAdapter<NumbersState>()({\n  setCoolNumber: (state, newCoolNumber: number) => ({\n    ...state,\n    coolNumber: newCoolNumber,\n  }),\n  setWeirdNumber: (state, newWeirdNumber: number) => ({\n    ...state,\n    weirdNumber: newWeirdNumber,\n  }),\n})({\n  setBothNumbers: {\n    coolNumber: numberAdapter.set,\n    weirdNumber: numberAdapter.set,\n  },\n})();\n```\n\n`setBothNumbers` becomes a reaction on `numbersAdapter` that sets both `coolNumber` and `weirdNumber` to the same payload passed into `setBothNumbers`. The new reaction's payload type will be the intersection of the payload types from the reactions used.\n\nThe reason grouped reactions are useful is because if you tried to reuse `setCoolNumber` and `setWeirdNumber`, you would end up calculating 2 new states:\n\n```typescript\nconst numbersAdapter = buildAdapter<NumbersState>()({\n  setCoolNumber: (state, newCoolNumber: number) => ({\n    ...state,\n    coolNumber: newCoolNumber,\n  }),\n  setWeirdNumber: (state, newWeirdNumber: number) => ({\n    ...state,\n    weirdNumber: newWeirdNumber,\n  }),\n})(([selectors, reactions]) => ({\n  setBothNumbers: (state, newNumber: number) =>\n    reactions.setWeirdNumber(reactions.setCoolNumber(state)),\n}))();\n```\n\nIf you tried to calculate a single new state, you would override properties from the first change with the unchanged properties from the second change, so passing the result of one reaction to the other is the only way to ensure consistent state without duplicating state change logic in the new state reaction. But this is inefficient.\n\nState change groups are able to efficiently calculate a single new state.\n\n## `joinAdapters`\n\nSimilar data types will have similar state management logic. Take this example we just saw above from [`buildAdapter`](/concepts/adapters#buildadapter):\n\n```typescript\nimport { buildAdapter } from '@state-adapt/core';\nimport { numberAdapter } from './number.adapter';\n\ninterface NumbersState {\n  coolNumber: number;\n  weirdNumber: number;\n}\n\nconst numbersAdapter = buildAdapter<NumbersState>()({\n  setCoolNumber: (state, newCoolNumber: number) => ({\n    ...state,\n    coolNumber: newCoolNumber,\n  }),\n  setWeirdNumber: (state, newWeirdNumber: number) => ({\n    ...state,\n    weirdNumber: newWeirdNumber,\n  }),\n})();\n```\n\nSee how both properties are numbers and end up with the same state change? What would be awesome is if we could define individual adapters for these properties and automatically inheret the state changes for those properties in our parent state adapter:\n\n```typescript\nimport { joinAdapters } from '@state-adapt/core';\nimport { numberAdapter } from './number.adapter';\n\ninterface NumbersState {\n  coolNumber: number;\n  weirdNumber: number;\n}\n\nconst numbersAdapter = joinAdapters<NumbersState>()({\n  coolNumber: numberAdapter,\n  weirdNumber: numberAdapter,\n})();\n```\n\nThis will produce the same adapter as in the previous code snippet.\n\n[`joinAdapters`](/concepts/adapters#joinadapters) returns the same builder function as [`buildAdapter`](/concepts/adapters#buildadapter). So we can add our grouped reaction just like we did in the [`buildAdapter`](/concepts/adapters#buildadapter) example:\n\n```typescript\nimport { joinAdapters } from '@state-adapt/core';\nimport { numberAdapter } from './number.adapter';\n\ninterface NumbersState {\n  coolNumber: number;\n  weirdNumber: number;\n}\n\nconst numbersAdapter = joinAdapters<NumbersState>()({\n  coolNumber: numberAdapter,\n  weirdNumber: numberAdapter,\n})({\n  setBothNumbers: {\n    coolNumber: numberAdapter.set,\n    weirdNumber: numberAdapter.set,\n  },\n})();\n```\n\nAll selectors from `number` adapter (see [`createAdapter`](/concepts/adapters#createadapter)) will get prepended with the namespace we've defined. So we get these selectors:\n\n```typescript\n{\n  coolNumberNegative: state => state.coolNumber * -1,\n  weirdNumberNegative: state => state.coolNumber * -1,\n}\n```\n\nAll state reactions have the namespace inserted after the first word. So we get these reactions:\n\n```typescript\n{\n  addCoolNumber: (state, n: number) => ({...state, coolNumber: state.coolNumber + n}),\n  subtractCoolNumber: (state, n: number) => ({...state, coolNumber: state.coolNumber - n}),\n  addWeirdNumber: (state, n: number) => ({...state, weirdNumber: state.weirdNumber + n}),\n  subtractWeirdNumber: (state, n: number) => ({...state, weirdNumber: state.weirdNumber - n}),\n}\n```\n\nThis may change in the future to simple prefixing like selectors, depending on what we find as we use this on real-world problems. Here are some example state change names and what they'd end up as with `joinAdapters`:\n\n- `set` => `setFeature`\n- `setLoadingToTrue` => `setFeatureLoadingToTrue`\n- `toggle` => `toggleFeature`\n- `decrementPopulation` => `decrementFeaturePopulation`\n- `setTo5` => `setFeatureTo5`\n\nIf you have a large state model and don't want to define an adapter for every property, [`joinAdapters`](/concepts/adapters#joinadapters) takes in a 2nd type argument for you to specify which properties to exclude:\n\n```typescript\nimport { joinAdapters } from '@state-adapt/core';\nimport { numberAdapter } from './number.adapter';\n\ninterface NumbersState {\n  coolNumber: number;\n  weirdNumber: number;\n  a: string;\n  b: any;\n  c: Record<string, undefined>;\n}\n\nconst numbersAdapter = joinAdapters<NumbersState, 'a' | 'b' | 'c'>()({\n  coolNumber: numberAdapter,\n  weirdNumber: numberAdapter,\n})();\n```\n\n## `mapPayloads`\n\n`mapPayloads` takes in an object with adapter reactions as the first argument, an object with payload mappers as the second argument, and returns the mapped reactions. For example, if you had this adapter:\n\n```typescript\nconst numberAdapter = createAdapter<number>()({\n  add: (state, n: number) => state + n,\n  subtract: (state, n: number) => state - n,\n  selectors: {\n    negative: state => state * -1,\n  },\n});\n```\n\nYou could change the payloads of any of the reactions with `mapPayloads`:\n\n```typescript\nconst addFromStringAdapter = mapPayloads(numberAdapter, {\n  add: (nStr: string) => +nStr,\n});\n```\n\nThat would would return an object like this:\n\n```typescript\n{\n  add: (state: number, nStr: string) => +nStr,\n}\n```\n\nThis is useful with [`buildAdapter`](/concepts/adapters#buildadapter), because when defining new reactions you only return the new reactions. So you could do something like this:\n\n```typescript\nconst numberAdapter = buildAdapter<number>()({\n  add: (state, n: number) => state + n,\n  subtract: (state, n: number) => state - n,\n  selectors: {\n    negative: state => state * -1,\n  },\n})(([selectors, reactions]) =>\n  mapPayloads(\n    {\n      add5: reactions.add, // add5 expects a payload still\n      add10: reactions.add, // add10 expects a payload still\n      add15: reactions.add, // add15 expects a payload still\n    },\n    {\n      add5: () => 5, // add5 is now a reaction that doesn't take a payload\n      add10: () => 10, // add10 is now a reaction that doesn't take a payload\n      add16: () => 15, // add15 is now a reaction that doesn't take a payload\n    },\n  ),\n)();\n```\n\nThe result would be the same as defining an adapter like this:\n\n```typescript\nconst numberAdapter = createAdapter<number>()({\n  add: (state, n: number) => state + n,\n  add5: state => state + 5,\n  add10: state => state + 10,\n  add15: state => state + 15,\n  subtract: (state, n: number) => state - n,\n  selectors: {\n    negative: state => state * -1,\n  },\n});\n```\n\n[`mapPayloads`](/concepts/adapters#mappayloads) is most useful when you want to define an adapter with ideal payloads, but actually need an adapter that takes in annoying payload types. For example, if you are receiving data from an API, you might want to write an adapter like this:\n\n```typescript\nconst dataAdapter = createAdapter<WithData>()({\n  receiveData: (state, data: Data) => ({ ...state, data }),\n});\n```\n\nBut then you might have an `HTTP` source like this:\n\n```typescript\ninterface ApiData {\n  weirdly: {\n    nested: {\n      response: {\n        shape: {\n          with: {\n            data: Data;\n          };\n        };\n      };\n    };\n  };\n}\n```\n\nYou would like to keep your `dataAdapter` defined how it is, so you can use `mapPayloads` here:\n\n```typescript\nconst dataAdapter = createAdapter<WithData>()({\n  receiveData: (state, data: Data) => ({ ...state, data }),\n});\n\nconst apiDataAdapter = buildAdapter<WithData>()(dataAdapter)(([s, reactions]) =>\n  mapPayloads(reactions, {\n    receiveData: (data: ApiData) =>\n      data.weirdly.nested.response.shape.with.data,\n  }),\n);\n```\n\nThis is preferable over either modifying the simpler `dataAdapter` _or_ modifying the HTTP source observable with `.pipe(map(...))`. Sources should be as simple as possible. Adapters are the perfect place to put mapping logic.\n\nNote: If you use the same reaction name, like in this example, make sure it is in a separate [`buildAdapter`](/concepts/adapters#buildadapter) call from the one that defined it. Otherwise the original reaction will be redefined when [`buildAdapter`](/concepts/adapters#buildadapter) mutates the adapter. But if you use `mapPayloads` in a separate [`buildAdapter`](/concepts/adapters#buildadapter) call, the original adapter object will be unaffected, since [`buildAdapter`](/concepts/adapters#buildadapter) always creates a new initial object.\n\n## Adapter Creator Libraries\n\nState adapters allow state management patterns to be easily reusable.\n\nSimilar to how components enabled awesome component libraries for modern UI frameworks, state adapters open up the opportunity for adapter libraries.\n\nStateAdapt has created a few core adapters, and plans to create many more. See the [core adapters documentation](/adapters/core).\n"}}return n.\u0275fac=function(a){return new(a||n)},n.\u0275cmp=e.Xpm({type:n,selectors:[["sa-adapters"]],standalone:!0,features:[e.jDz],decls:8,vars:1,consts:[[3,"data"],["routerLink","/concepts/stores"],["routerLink","/concepts/sources"]],template:function(a,u){1&a&&(e.TgZ(0,"sa-content"),e._UZ(1,"markdown",0),e.TgZ(2,"h2")(3,"a",1),e._uU(4,"Next: Stores"),e.qZA()(),e.TgZ(5,"h2")(6,"a",2),e._uU(7,"Previous: Sources"),e.qZA()()()),2&a&&(e.xp6(1),e.Q6J("data",u.md))},dependencies:[s.Bz,s.yS,p.S,o.JP,o.lF],encapsulation:2}),n})()}}]);