"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[505],{7505:(l,s,t)=>{t.r(s),t.d(s,{StoresComponent:()=>p});var n=t(6087),r=t(1917),c=t(2309),e=t(4650);let p=(()=>{class o{constructor(){this.html='<h1 id="stores">Stores</h1>\n<ul class="bx--list--unordered"><li class="bx--list__item"><a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/concepts/stores#overview\'})); void(0)">Overview</a></li><li class="bx--list__item"><a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/concepts/stores#init\'})); void(0)"><code>init</code></a></li><li class="bx--list__item"><a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/concepts/stores#state-paths\'})); void(0)">State Paths</a></li><li class="bx--list__item"><a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/concepts/stores#getid\'})); void(0)">getId</a></li><li class="bx--list__item"><a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/concepts/stores#selectors\'})); void(0)">Selectors</a></li><li class="bx--list__item"><a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/concepts/stores#watch\'})); void(0)"><code>watch</code></a></li><li class="bx--list__item"><a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/concepts/stores#joining-stores\'})); void(0)">Joining Stores</a></li></ul><h2 id="overview">Overview</h2>\n<p>Stores do 4 things:</p>\n<ul class="bx--list--unordered"><li class="bx--list__item">Define initial state and an adapter to manage it</li><li class="bx--list__item">Use sources to trigger adapter state changes</li><li class="bx--list__item">Use the adapter&#39;s selectors to create observables of selector results. These observables chain off the sources so subscriptions are propagated</li><li class="bx--list__item">Use the adapter&#39;s state changes to create synthetic sources for simple, single-store state changes. These are made available as part of the store, so DOM event handlers can call them. See <a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/concepts/sources#synthetic-sources\'})); void(0)">Synthetic Sources</a>.</li></ul><p><strong>Stores <em>do not</em> subscribe to sources on their own. Nothing will happen until you subscribe to one of the selector observables.</strong></p>\n<h2 id="init"><code>init</code></h2>\n<p><code>init</code> is a method on <code>Adapt</code> that creates stores. There are 4 ways to use it:</p>\n<p><img src="../assets/adapt-method-jsdoc.png" alt="Adapt[&#39;init&#39;] Overloads" /></p>\n<p>The <code>sources</code> parameter needs explaining. When it is an object, it maps relationships between state changes and the sources that should trigger them. This object is equivalent to a reducer in <em>Redux</em> or <em>NgRx</em>. The property names of the object are the adapter&#39;s state change function names. The right-hand side of the object specifies one or more sources that should trigger the state change specified in the property name. To specify multiple sources, pass them in an array, like</p>\n<pre><code class="language-typescript">{\n  add: [this.numberAdded$, this.aDifferentNumberAdded$],\n}\n</code></pre>\n<p><code>sources</code> can also be a single observable or array of observables that gets treated the same as if this was passed in like <code>{ set: source$ }</code> or <code>{ set: [source1$, source2$] }</code></p>\n<p>This is the default way to use <a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/concepts/stores#init\'})); void(0)"><code>init</code></a> from <code>&#39;@state-adapt/rxjs&#39;</code>:</p>\n<pre><code class="language-typescript">import { Adapt } from &#39;@state-adapt/rxjs&#39;;\n// ...\n  numberStore = this.adapt.init(&#39;number&#39;, 0);\n  constructor(private adapt: Adapt) {}\n// ...\n</code></pre>\n<p>You will probably never call the <a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/concepts/stores#init\'})); void(0)"><code>init</code></a> method directly. StateAdapt exports a specific function for each environment:</p>\n<ul class="bx--list--unordered"><li class="bx--list__item"><strong>Angular:</strong> <code>import { adapt } from &#39;@state-adapt/angular&#39;;</code></li><li class="bx--list__item"><strong>Angular + NgRx:</strong> <code>import { adaptNgrx } from &#39;@state-adapt/ngrx&#39;;</code></li><li class="bx--list__item"><strong>Angular + NGXS:</strong> <code>import { adaptNgxs } from &#39;@state-adapt/ngxs&#39;;</code></li><li class="bx--list__item"><strong>React (/+ Redux):</strong> <code>import { useAdapt } from &#39;@state-adapt/react&#39;;</code></li></ul><p>The signature for each of these is the same as <a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/concepts/stores#init\'})); void(0)"><code>init</code></a>&#39;s.</p>\n<h2 id="state-paths">State Paths</h2>\n<p>The <a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/concepts/stores#state-paths\'})); void(0)">path</a> string passed into <a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/concepts/stores#init\'})); void(0)"><code>init</code></a> specifies the location in the global store you will find the state for the store being created. StateAdapt splits this string at periods <code>&#39;.&#39;</code> and uses the resulting array to define an object path for the state. For example, with an initial state of <code>0</code>, the following paths will create the following objects for the global store:</p>\n<pre><code class="language-typescript">&#39;number&#39; ==&gt; { number: 0 }\n\n&#39;featureA.number&#39; ==&gt; { featureA: { number: 0 } }\n\n&#39;featureA.featureB.number&#39; ==&gt; { featureA: { featureB: { number: 0 } } }\n</code></pre>\n<p>Each store completely owns its own state. If more than one store tries to use the same path, StateAdapt will throw this error:</p>\n<p><code>Path &#39;${path}&#39; collides with &#39;${existingPath}&#39;, which has already been initialized as a state path.</code></p>\n<p>This applies both to paths that are identical as well as paths that are subtrings of each other. For example, if <code>&#39;featureA&#39;</code> is already being used by a store and then another store tried to initialize at <code>&#39;featureA.number&#39;</code>, that error would be thrown.</p>\n<h2 id="getid"><code>getId</code></h2>\n<p>In case you need to avoid a path collision and have no way of generating a unique path deterministically, <a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/concepts/stores#getid\'})); void(0)"><code>getId</code></a> will give you a unique id you can append to the path you pass into <a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/concepts/stores#init\'})); void(0)"><code>init</code></a>.</p>\n<h2 id="selectors">Selectors</h2>\n<p>Selectors defined in an adapter get assigned to properties on the store object with an added <code>&#39;$&#39;</code> at the end of the property name. They are observables of the selected state:</p>\n<pre><code class="language-typescript">numberAdapter = createAdapter&lt;number&gt;()({\n  selectors: { negative: state =&gt; state * -1 },\n});\nnumberStore = this.adapt.init([&#39;number&#39;, 0], this.numberAdapter);\nnegativeNumber$ = this.numberStore.negative$;\nstate$ = this.numberStore.state$; // Every adapter gets a `state` selector\n</code></pre>\n<p>Each selector&#39;s observable chains off of all the sources passed into the store. For example, if one of your sources is an observable of an HTTP request, that request will automatically be triggered as soon as you subscribe to any of the selector observables from the store. If necessary, you can access store selectors that do not chain off of any sources by using the <a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/concepts/stores#watch\'})); void(0)"><code>watch</code></a> method described next.</p>\n<h2 id="watch"><code>watch</code></h2>\n<p><a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/concepts/stores#watch\'})); void(0)"><code>watch</code></a> is a method on <code>Adapt</code> that returns a store that does not chain off of sources. It takes 2 arguments: The <a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/concepts/stores#state-paths\'})); void(0)">path</a> of the state you are interested in, and the adapter containing the selectors you want to use:</p>\n<pre><code class="language-typescript">import { watch } from &#39;@state-adapt/angular&#39;;\n// ...\nnegative$ = watch(&#39;number&#39;, numberAdapter).negative$;\n</code></pre>\n<p><a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/concepts/stores#watch\'})); void(0)"><code>watch</code></a> is useful in 2 situations primarily: <a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/concepts/stores#1-accessing-state-without-subscribing\'})); void(0)">Accessing state without subscribing</a> and <a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/concepts/stores#2-accessing-state-for-a-source\'})); void(0)">accessing state for a source</a>.</p>\n<h3 id="1-accessing-state-without-subscribing">1. Accessing State without Subscribing</h3>\n<p><a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/concepts/stores#watch\'})); void(0)"><code>watch</code></a> enables accessing state without subscribing to sources. For example, if your adapter manages the <code>loading</code> state for an HTTP request and you need to know if the request is loading <em>before</em> the user is interested in the data, <a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/concepts/stores#watch\'})); void(0)"><code>watch</code></a> can give you access to it without triggering the request. This is probably not common, but <a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/concepts/stores#watch\'})); void(0)"><code>watch</code></a> makes it possible.</p>\n<h3 id="2-accessing-state-for-a-source">2. Accessing State for a Source</h3>\n<p>It would be impossible for a source itself to access state from the store without <a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/concepts/stores#watch\'})); void(0)"><code>watch</code></a> because it would require using the store before it had been defined. The following example demonstrates this:</p>\n<pre><code class="language-typescript">dataReceived$ = this.dataStore.dataNeeded$.pipe(\n  // Error: Property &#39;dataStore&#39; is used before its initialization.\n  filter(needed =&gt; needed),\n  switchMap(() =&gt; this.dataService.fetchData()),\n  toSource(&#39;dataReceived$&#39;),\n);\n\ndataStore = adapt([&#39;data&#39;, initialState, dataAdapter], {\n  receive: this.dataReceived$,\n});\n</code></pre>\n<p>In this example <code>dataNeeded$</code> comes from a selector that returns <code>true</code> if data needs to be fetched. This could be useful if the user is given a refresh button which triggers a state change back to the initial state. Since the <code>dataReceived$</code> source chains off of <code>dataNeeded$</code>, this reset would automatically trigger the request to be made again. Very reactive!</p>\n<p>However, <code>dataReceived$</code> needs to reference <code>this.dataStore.dataNeeded$</code>, which is impossible because <code>dataStore</code> uses <code>dataReceived$</code>. It is a circular reference problem.</p>\n<p><a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/concepts/stores#watch\'})); void(0)"><code>watch</code></a> solves this:</p>\n<pre><code class="language-typescript">dataNeeded$ = watch(&#39;data&#39;, dataAdapter).dataNeeded$;\n\ndataReceived$ = this.dataNeeded$.pipe(\n  filter(needed =&gt; needed),\n  switchMap(() =&gt; this.dataService.fetchData()),\n  toSource(&#39;dataReceived$&#39;),\n);\n\ndataStore = adapt([&#39;data&#39;, initialState, dataAdapter], {\n  receive: this.dataReceived$,\n});\n</code></pre>\n<h2 id="joining-stores">Joining Stores</h2>\n<p>Stores are treated as independent entities responsible for managing only the state inside of them. But sometimes you need to combine state from multiple stores. Since <a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/concepts/stores#the-problem-with-combinelatest\'})); void(0)"><code>combineLatest</code> is often inadequate</a>, StateAdapt has <a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/concepts/stores#joinstores\'})); void(0)"><code>joinStores</code></a>.</p>\n<h3 id="the-problem-with-combinelatest">The Problem with <code>combineLatest</code></h3>\n<p>When multiple stores change state simultaneously, a <code>combineLatest</code> that combines state from all of them will fire once for each store instead of once for all of them. This is not performant and requires you to filter out intermediate states where some inputs are new while others are old. Consider this example:</p>\n<pre><code class="language-typescript">numberAdded$ = new Source&lt;number&gt;();\n\nnumber1$ = adapt([&#39;number1&#39;, 0, numberAdapter], {\n  add: this.numberAdded$,\n}).state$;\nnumber2$ = adapt([&#39;number2&#39;, 4000, numberAdapter], {\n  add: this.numberAdded$,\n}).state$;\n\ntotal$ = combineLatest([this.number1$, this.number2$]).pipe(\n  map((n1, n2) =&gt; n1 + n2),\n);\n</code></pre>\n<p>Initially, <code>total$</code> will emit <code>4000</code>, calculated from the initial inputs of <code>0</code> and <code>4000</code>. If you then call <code>numberAdded$.next(10)</code>, <code>total$</code> would first recalculate based on inputs of <code>10</code> and <code>4000</code>, so it would emit <code>4010</code>. After that it would get the update from <code>number2</code> and calculate from <code>10</code> and <code>4010</code> and emit the correct number, <code>4020</code>.</p>\n<h3 id="joinstores"><code>joinStores</code></h3>\n<p><a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/concepts/stores#joinstores\'})); void(0)"><code>joinStores</code></a> gives you access to all of each store&#39;s selectors by allowing you to specify a prefix to prepend to all selector names from each individual store. It returns a new store-like object with new selectors. It also has similar syntax to that of <a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/concepts/adapters#joinadapters\'})); void(0)"><code>joinAdapters</code></a>:</p>\n<pre><code class="language-typescript">import { joinStores } from &#39;@state-adapt/rxjs&#39;;\n// ...\nnumbersStore = joinStores({\n  one: this.number1Store,\n  two: this.number2Store,\n})({\n  totalNegative1: s =&gt; s.oneNegative + s.twoState,\n  totalNegative2: s =&gt; s.oneState + s.twoNegative,\n})();\n\ntotalNegative1$ = this.numbersStore.totalNegative1$;\ntotalNegative2$ = this.numbersStore.totalNegative2$;\n</code></pre>\n<p>The reason for the similar syntax is so you can define state logic in adapters instead of inside <code>joinStores</code>, which makes it simpler to test. This alternative syntax would be slightly preferrable:</p>\n<pre><code class="language-typescript">import { joinAdapters } from &#39;@state-adapt/core&#39;;\nimport { joinStores } from &#39;@state-adapt/rxjs&#39;;\n\nconst numbersStore = joinAdapters&lt;NumbersState&gt;()({\n  one: numberAdapter,\n  two: numberAdapter,\n})({\n  totalNegative1: s =&gt; s.oneNegative + s.twoState,\n  totalNegative2: s =&gt; s.oneState + s.twoNegative,\n})();\n// ...\nnumbersStore = joinStores({\n  one: this.number1Store,\n  two: this.number2Store,\n})(numbersStore.selectors)();\n\ntotalNegative1$ = this.numbersStore.totalNegative1$;\ntotalNegative2$ = this.numbersStore.totalNegative2$;\n</code></pre>\n<p>But it&#39;s easy to move from one to the other, so don&#39;t feel bad about defining selectors inside <a href="javascript:document.dispatchEvent(new CustomEvent(\'routeTo\', {detail: \'/concepts/stores#joinstores\'})); void(0)"><code>joinStores</code></a> itself.</p>\n'}}return o.\u0275fac=function(a){return new(a||o)},o.\u0275cmp=e.Xpm({type:o,selectors:[["sa-stores"]],standalone:!0,features:[e.jDz],decls:8,vars:1,consts:[[3,"html"],["routerLink","/concepts/thinking-reactively"],["routerLink","/concepts/adapters"]],template:function(a,h){1&a&&(e.TgZ(0,"sa-content"),e._UZ(1,"sa-html",0),e.TgZ(2,"h2")(3,"a",1),e._uU(4,"Next: Thinking Reactively"),e.qZA()(),e.TgZ(5,"h2")(6,"a",2),e._uU(7,"Previous: Adapters"),e.qZA()()()),2&a&&(e.xp6(1),e.Q6J("html",h.html))},dependencies:[n.Bz,n.yS,c.S,r.XB],styles:["state-adapt-stores img{max-width:100%}"]}),o})()}}]);